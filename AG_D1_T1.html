<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="favicon.ico">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script type="text/javascript" src="underscore-min.js"></script>
    <script type="text/javascript" src="SnapPLE.js"></script>
    <meta charset="utf-8">  <!-- This line is needed in order to pass strings into test functions that contain characters
    like "-" and what not. -->
    <!-- Moved down to the bottom to have var id. -->
    
    <!-- <script type="text/javascript" src="snap.js"></script> -->
    <script type="text/javascript" src="morphic.js"></script>
    <script type="text/javascript" src="widgets.js"></script>
    <script type="text/javascript" src="blocks.js"></script>
    <script type="text/javascript" src="threads.js"></script>
    <script type="text/javascript" src="objects.js"></script>
    <script type="text/javascript" src="gui.js"></script>
    <script type="text/javascript" src="paint.js"></script>
    <script type="text/javascript" src="lists.js"></script>
    <script type="text/javascript" src="byob.js"></script>
    <script type="text/javascript" src="xml.js"></script>
    <script type="text/javascript" src="store.js"></script>
    <script type="text/javascript" src="locale.js"></script>
    <script type="text/javascript" src="cloud.js"></script>
    <script type="text/javascript" src="sha512.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link rel="stylesheet" type="text/css" href="hintstyle.css" />
    <script type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">
        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser localStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;
        var isEDX = isEDXurl();

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
            /* Factorial */
            var assert1 = function assert1() {
                return scriptPresentInSprite('[{"blockSp":"factorial %s","inputs":["A"]}]',0,["A"]);
            }
            testAssert(outputLog, assert1,//isScriptPresent('factorial %s',0),
                "The 'factorial' block is present.", 
                "The 'factorial %num' block was not found on-screen.", 
                "Make sure you name your custom block, 'factorial %num'.");
            testAssert(outputLog, customBlockContains('factorial %s', 'factorial %s'),
                "The 'factorial' block has a recursive call to itself.",
                "There is no recursive call to 'factorial.",
                "Make sure you have a recursive call inside of 'factorial.");
            testAssert(outputLog, blockPrecedes('factorial %s', "%n âˆ’ %n", getCustomBody('factorial %s', 0)),
                "The recursive call to'factorial' block contains a minus block",
                "There is no minus block in the recursive call to 'factorial'.",
                "Make sure you have a minus block inside of the recursive call.");
            multiTestBlock('factorial %s', 
                [[0],[1],[2],[4],[5],[10]],
                [1,1,2,24,120,3628800],
                [-1,-1,-1,-1,-1,-1],
                [false,false,false,false,false,false])
            
            // /* KScopeTest */
            // testAssert(outputLog, 
            //     spriteContainsBlock('when %keyHat key pressed', 0, ['space']) &&
            //     spriteContainsBlock('when %keyHat key pressed', 1, ['space']) &&
            //     spriteContainsBlock('when %keyHat key pressed', 2, ['space']) &&
            //     spriteContainsBlock('when %keyHat key pressed', 3, ['space']),
            //     "All sprites have the 'when [space] key pressed' hat-block.",
            //     "All sprites must have a 'when [space] key pressed' hat-block.",
            //     "The Kaleidoscope should begin drawing when the 'space' key is pressed.");
            // testAssert(outputLog,
            //     spriteContainsBlock('forever %c', 0) &&
            //     spriteContainsBlock('forever %c', 1) &&
            //     spriteContainsBlock('forever %c', 2) &&
            //     spriteContainsBlock('forever %c', 3),
            //     "All sprites have a forever loop",
            //     "All sprites must have a 'forever' loop.",
            //     "The 'forever' loop is required.");
            // testAssert(outputLog,
            //     spriteContainsBlock('go to x: %n y: %n', 0) &&
            //     spriteContainsBlock('go to x: %n y: %n', 1) &&
            //     spriteContainsBlock('go to x: %n y: %n', 2) &&
            //     spriteContainsBlock('go to x: %n y: %n', 3),
            //     "All sprites have a 'go to' motion-block",
            //     "All sprites must have a 'go to' motion-block",
            //     "The 'go to' motion-block is required.");
            // testAssert(outputLog,
            //     spriteContainsBlock('pen down', 0) &&
            //     spriteContainsBlock('pen down', 1) &&
            //     spriteContainsBlock('pen down', 2) &&
            //     spriteContainsBlock('pen down', 3),
            //     "All sprites have a 'pen down' pen-block",
            //     "All sprites must have a 'pen down' pen-block",
            //     "The 'pen down' pen-block is required.");
            // testKScope(outputLog);
            /**/
            return outputLog;
        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            var numAttempts = setNumAttempts(taskID);
            outputLog = outputLog || new gradingLog(snapWorld, taskID, numAttempts);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer. 

            //outputLog.numAttempts += 1;

            var test_log = AGTest(outputLog);
            if(!test_log.runSnapTests()) {
                outputLog.scoreLog();
            }
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog; 
            } else {
                //Restore the AG status bar to a graded state
                //If no previous state is recognized, return new {gradingLog}.
                var numAttempts = setNumAttempts(taskID);
                outputLog = new gradingLog(snapWorld, taskID, numAttempts); 
                AG_bar_ungraded(outputLog);
                return outputLog;
            }   
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {

            

            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            //Retrieve previous grade logs (if in localStorage). As {String}s
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                console.log(prev_xml);
                console.log(curr_xml);
            }


            //menu bar grays out options that are not available 
            //(ex. current state is same as best attempt) and restores the button state

            grayOutButtons(snapWorld, taskID);

            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {               
                //Restore the AG status bar to a graded state
                
                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string
                console.log('AGUpdate: Thinks this is the "correct" XML.');
                localStorage.setItem(taskID + "_test_log", c_prev_log);
                localStorage.setItem(taskID + "_test_state", curr_xml);
                document.getElementById("different-feedback").innerHTML = "";

                //Retrieve the correct test log from localStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);

                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "none";
                }

            } else if (prev_xml && isSameSnapXML(prev_xml, curr_xml, true)) {
                //Restore the AG status bar to a graded state
                console.log('AGUpdate: Thinks this is just the "last" XML.');
                //Retrieve the previous test log from localStorage
                document.getElementById("different-feedback").innerHTML = "";

                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "none";
                }

            } else {
                //Restore the AG status bar to a graded state
                var numAttempts = setNumAttempts(taskID);
                outputLog = new gradingLog(snapWorld, taskID, numAttempts);
                AG_bar_ungraded(outputLog);
                document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "block";
                }

            }
            //populateFeedback(outputLog);
            return outputLog;

        }

        /* Updates the AG_status_bar with respect to the outputLog. 
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into 
         * localStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {
            // Verify correctness
            if (outputLog.allCorrect) {
                // Save the correct XML string into localStorage
                AG_bar_graded(outputLog);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");
            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(outputLog);
            }
            //Save the current XML. Log is saved in gradingLog.scoreLog(...)
            outputLog.saveSnapXML(outputLog.taskID + "_test_state");
            //outputLog.numAttempts += 1;
            populateFeedback(outputLog);
            grayOutButtons(outputLog.snapWorld, outputLog.taskID);
            console.log('Autograder test Results:');
            console.log(outputLog);
            //parent.document.getElementsByClassName('check-label')[0].click();
        }
        /*
         * Reset state removes all saved logs and XML files, and opens a new
         * Snap! file. 
         */
        function resetState(snapWorld, taskID) {

            var numAttempts = JSON.parse(localStorage.getItem(taskID + "_test_log")).numAttempts;

            localStorage.removeItem(taskID + "_test_log");
            localStorage.removeItem(taskID + "_test_state");
            localStorage.removeItem(taskID + "_c_test_log");
            localStorage.removeItem(taskID + "_c_test_state");

            var ide = snapWorld.children[0];
            ide.newProject();
            var new_log = AGStart(snapWorld, taskID);
            new_log.numAttempts = numAttempts;
            //localStorage.setItem(taskID + "_test_log", new_log);
            localStorage.setItem(taskID + "_test_state", ide.serializer.serialize(ide.stage));
            new_log.saveLog();
            //localStorage.setItem(taskID + "_test_log", new_log);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToBestState(snapWorld, taskID) {
    
            var ide = snapWorld.children[0];

            var numAttempts = JSON.parse(localStorage.getItem(taskID + "_test_log")).numAttempts;

            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            localStorage.setItem(taskID + "_test_state", c_prev_xml);
            localStorage.setItem(taskID + "_test_log", c_prev_log);

            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            AG_bar_graded(prev_log);
            populateFeedback(prev_log);
            prev_log.numAttempts = numAttempts;
            ide.openProjectString(c_prev_xml);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToLastState(snapWorld, taskID) {

            var ide = snapWorld.children[0];
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(prev_xml);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToLastSubmit(snapWorld, taskID) {
            var numAttempts = JSON.parse(localStorage.getItem(taskID + "_test_log")).numAttempts;

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var ide = snapWorld.children[0];

            localStorage.setItem(taskID + "_test_state", last_xml);
            localStorage.setItem(taskID + "_test_log", last_log);
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            prev_log.numAttempts = numAttempts;
            ide.openProjectString(last_xml);
            grayOutButtons(snapWorld, taskID);

        }

        /*
         * Makes AG status bar reflect the ungraded state of the outputLog.
         */
        function AG_bar_ungraded(outputLog) {
            var button_text = "GRADE";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'orange');
            });          
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'white');
            if (localStorage.getItem(outputLog.taskID + "_test_log")) {
                $('#feedback-button').html("View Previous Feedback");
            } else {
                $('#feedback-button').html("No Feedback Available");
            }
            document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
        }

        /*
         * Makes AG status bar reflect the graded state of the outputLog. This
         * only occurs when all tests on the outputLog have passed.
         */
        function AG_bar_graded(outputLog) {
            var button_text = "TESTS PASS";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', '#29A629');
            });
            $('#autograding_button .hover_darken').hide();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("Review Feedback");
        }
        /*
         * Makes AG status bar reflect the semi graded state of the outputLog. 
         * This is called when any test on the outputLog fails.
         */
        function AG_bar_semigraded(outputLog) {
            var button_text = "&#x2770&#x2770 FEEDBACK";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp("FEEDBACK","g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'red');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'orange');
            var num_errors = outputLog.testCount - outputLog.numCorrect;
            var plural = "";
            if (num_errors > 1) { plural = "s"};
            $('#feedback-button').html("View Feedback ("+ 
                num_errors +" Error" + plural + ")");
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated. 
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position  
         *  - Option to restore the highest scoring {gradingLog}
         *  
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml, no_subset) {
            //replace script coordinates with generic 'x="0" y="0"'
            // console.log('isSameSnapXML');
            if ((prev_xml === null) || (curr_xml === null)) { return false; }
            //Remove script coordinates
            // prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            // curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            prev_xml = prev_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');
            //If XML is identical other than images and script positions, short-circuit
            if (prev_xml === curr_xml) { return true; }
            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);
            //split between custom blocks
            prev_xml_blocks = prev_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            curr_xml_blocks = curr_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");
            //If the custom block definitions have changed
            prev_xml_blocks && prev_xml_blocks.sort().join("");
            curr_xml_blocks && curr_xml_blocks.sort().join("");
            if(JSON.stringify(prev_xml_blocks) !== JSON.stringify(curr_xml_blocks)) {
                return false;
            }
            //If the previous scripts are a subset of current scripts
            if (!no_subset && isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }
            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);
            return prev_xml === curr_xml;
        }

        /*
         * Helper Function for isSameSnapXML(...). Used to check if a previous
         * solution is a sub-set of the current Snap! scripts.
         * @param {Array:Strings} big
         * @param {Array:String} small
         * @return {Boolean} If 'small' is a sub-set of 'big'
         */
        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags = 
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'], 
            ['collapsedivend', '</div>'], 
            ['linebreak', '<br /></br />'], 
            ['tablestart', '<table class="results">'], 
            ['tableend', '</table>'], 
            ['rowstart', '<tr>'], 
            ['rowend', '</tr>'], 
            ['headstart', '<th class="titles" style="text-align: center;">'], 
            ['headend', '</th>'], 
            ['datastart', '<td class="data" style="text-align: center;">'], 
            ['evenstart', '<td class="evens" style="text-align: center;">'],
            ['dataend', '</td>'], 
            ['correctstart', '<td class="correctans" style="text-align: center;">'],
            ['wrongstart', '<td class="incorrectans" style="text-align: center;">'],
            ['teststart', '<td class="tests" style="text-align: center;">'],
            ['spanend', '</span>'], 
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }


        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        function openPopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.remove("is-hidden");
        }

        function closePopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.add("is-hidden");
        }

        function openResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.remove("is-hidden");
        }

        function closeResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.add("is-hidden");
        }

        function populateFeedback(outputLog) {
            var taskID = outputLog.taskID;
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            var edx_caution = document.getElementById("edx-submit-different");
            var caution = document.getElementById("different-feedback");

            var glog = outputLog;
            var log = AG_log(glog);
            var feedback = log["feedback"];
            var title = log["comment"];

            // Checks if the grading button has been clicked
            if (title === "Please run the Snap Autograder before clicking the 'Submit' button.") {
                document.getElementById("table-data").style.display = "none";
                document.getElementById("reporter-table-data").style.display = "none";
            } else {
                document.getElementById("table-data").style.display = "table";
                document.getElementById("reporter-table-data").style.display = "table";
            }

            // Wipes the feedback clean, including if it has been populated before. 
            caution.innerHTML = "";
            edx_caution.innerHTML = "";
            document.getElementById("comment").innerHTML = "";
            var tableTitles = document.getElementsByClassName("titles");
            var tableResults = document.getElementById("table-data");
            var repTableResults = document.getElementById("reporter-table-data");
            while (tableResults.children.length > 1) {
                tableResults.removeChild(tableResults.children[1]);
            }
            while (repTableResults.children.length > 1) {
                repTableResults.removeChild(repTableResults.children[1]);
            }

            // Warnings for when student's feedback differ from what's on the scripting area/what's been submitted to edX
            document.getElementById("comment").innerHTML = title;
            if (!last_log) {
                edx_caution.innerHTML = "[WARNING: You have not submitted your results to edX yet.]"
            }
            else if (last_log !== prev_log) {
                edx_caution.innerHTML = "[WARNING: These results differ from your last edX submission.]"
            }

            var nonRepTest = 1;
            var repTest = 1;
            for (i=1; i<=feedback["testCount"]; i++) {
                var test = String(i);
                var newRow = document.createElement("tr");

                // If test is not a reporter test, only add columns for Test # and Feedback
                if (feedback[test]["testClass"] !== "r") {
                    if (document.getElementsByClassName("non-reporter").length === 0) {
                        addBasicHeadings();
                    }
                    addTableCell(String(nonRepTest), "tests", newRow);
                    nonRepTest += 1;
                }

                // If test is a reporter test, add all columns, including input, output, and expected. Makes the background of every other row light gray.
                if (feedback[test]["testClass"] === "r") {
                    if (document.getElementsByClassName("reporter").length === 0) {
                        addReporterHeadings();
                    }
                    addTableCell(String(repTest), "tests", newRow);
                    var keys = ["input", "output", "expOut"];
                    for (key=0; key<3; key++) {
                        if (repTest % 2 === 0) {
                            addTableCell(feedback[test][keys[key]], ["data", "evens"], newRow);
                        } else {
                            addTableCell(feedback[test][keys[key]], "data", newRow);
                        }
                    }
                    repTest += 1;
                }

                // If test is correct, make the feedback appropriately colored. 
                if (feedback[test]["correct"] === true) {
                    addTableCell(feedback[test]["feedback"], "correctans", newRow);
                    addRegradeButton("Regrade", ["data", "hidden"], newRow);
                } else {
                    addTableCell(feedback[test]["feedback"], "incorrectans", newRow);
                    addRegradeButton("Regrade", ["data", "regrade", test], newRow);
                }

                if (feedback[test]["testClass"] === "r") {
                    document.getElementById("reporter-table-data").appendChild(newRow);
                } else {
                    document.getElementById("table-data").appendChild(newRow);
                }  
            }
            console.log(outputLog);
            //outputLog.saveLog();

            // makes recently created regrade buttons clickable 
            var regrade_buttons = document.getElementsByClassName("regrade");
            for(var i=0; i<regrade_buttons.length; i++) {
                regrade_buttons[i].onclick = function() {
                    var testId = this.classList[2];
                    regradeOnClick(outputLog, testId);
                }
            }
        }

        function addBasicHeadings() {
            basicCols = ["Test", "Feedback"];
            for (i=0; i<2; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(basicCols[i]);
                //var lastCol = document.getElementById("reporter-last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles", "non-reporter");
                header.appendChild(text);
                titles.appendChild(header);
            }
        }

        function addReporterHeadings() {
            var columns = ["Test", "Input", "Output", "Expected", "Feedback"];
            for (i=0; i<5; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(columns[i]);
                var repTitles = document.getElementById("reporter-table-titles");
                header.classList.add("titles", "reporter");
                header.appendChild(text);
                repTitles.appendChild(header);
            }
        }

        function addTableCell(text, elemClass, row) {
            var data = document.createElement("td");
            var text = document.createTextNode(text);
            data.appendChild(text);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function addRegradeButton(text, elemClass, row) {
            var data = document.createElement("td");
            var button = document.createElement("p");
            var text = document.createTextNode(text);
            button.classList.add("regrade-button");
            button.appendChild(text);
            data.appendChild(button);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function grayOutButtons(snapWorld, taskID) {
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");

            var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }
        }

        function regradeOnClick(outputLog, testId) {
            var test = outputLog[testId];
            test.graded = false;
            test.correct = false;
            outputLog.numAttempts += 1;
            if (test.testClass === "r") {
                outputLog.startSnapTest(parseInt(testId, 10));

            // for assertion tests, change feedback accordingly to whether assertion is true or false
            } else if (test.testClass === "a") {
                if (test.assertion()) {
                    test.feedback = test.pos_fb;
                    test.correct = true;
                } else {
                    test.feedback = test.neg_fb;
                    test.correct = false;
                }
                test.graded = true;
            }

            //What about other types of tests?

            outputLog.scoreLog();
            console.log(outputLog);
        }

        function setNumAttempts(taskID) {
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (prev_log !== null && JSON.parse(prev_log).numAttempts !== undefined) {
                return JSON.parse(prev_log).numAttempts;
            } else {
                return 0;
            }
        }

        function isEDXurl() {
            var url = window.location.href;
            if (url.indexOf("edx") !== -1) {
                return true;
            } else {
                return false;
            }
        }

        function makeOverlayButton() {
            var overlay_button = parent.document.createElement('button');
            var overlay_button_text = parent.document.createTextNode('Grade');
            overlay_button.appendChild(overlay_button_text);
            overlay_button.id = 'overlay-button';
            var button =  parent.document.getElementsByName('problem_id')[0];
            button.parentNode.insertBefore(overlay_button, button.nextSibling);
        }

        function makeFullScreenButton() {
            var autograding_bar = document.getElementById('autograding_bar');
            var full_screen_button = document.createElement('button');
            var full_screen_button_text = document.createTextNode("Full-Screen");
            full_screen_button.appendChild(full_screen_button_text);
            full_screen_button.id = "full-screen";
            full_screen_button.className = "off";
            autograding_bar.parentNode.insertBefore(full_screen_button, autograding_bar.nextSibling);
        }

        function toggleSnapWindow(button) {
            var iframe = parent.document.getElementsByTagName('iframe')[0];
            if (button.className === "off") {
                iframe.style.position = 'fixed';
                iframe.style.top = '0';
                iframe.style.right = '0';
                iframe.style.width = '100%';
                iframe.style.height = '100vh';
                iframe.style.zIndex = '99';
                button.className = "on";
                /*button.style.position = 'fixed';
                button.style.right = '0';
                button.style.bottom = '0';*/
            } else {
                iframe.style.position = 'initial';
                iframe.style.top = 'initial';
                iframe.style.right = 'initial';
                //iframe.style.width = 'initial';
                iframe.style.height = '500px';
                iframe.style.zIndex = 'initial';
                button.className = "off";
                /*button.style.position = 'absolute';
                button.style.right = '31px';
                button.style.bottom = '225px';*/
            }
        }

        var world;
        window.onload = function () {

            //check if attempt num for problem exists in local storage:

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked

            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);


            var ide = world.children[0];
            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(localStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = localStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(localStorage.getItem(preReqID));
                }
            }
            

            //AUTOGRADER ADDITION - 
            //Forced to use setTimeout() to let the world load before... Maybe not.
            
            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            var update_listener = function() {
                var outputLog = AGUpdate(world, id);
                populateFeedback(outputLog);
            };
            var button_listener = function(event) {
                event.stopPropagation();
                console.log('PROPAGATION SHOULD STOP');
                var numAttempts = setNumAttempts(id);
                outputLog = new gradingLog(world, id, numAttempts);
                outputLog.numAttempts += 1;
                runAGTest(world, id, outputLog);
                if (isEDX) {
                    parent.document.getElementsByClassName('check-label')[0].click();
                } 
                // var outputLog = AGStart(world, id);
            }
            grade_button.addEventListener('click', button_listener);
            var world_canvas = document.getElementById('world');
            world_canvas.addEventListener("mouseup", update_listener);

            // grade_button.onclick = function(event) {
            //     // event.stopPropagation();
            //     runAGTest(world, id);
            //     var outputLog = AGStart(world, id);
            //     //console.log(outputLog);
            //     //populateFeedback(outputLog);
            // }



            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var undo_button = document.getElementById("undo-button");
            var last_submit = document.getElementById("last-submit");
            //var menu_button = document.getElementById("hamburger-menu");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];
            //var help_menu = document.getElementById("circle");
            var help_overlay = document.getElementById('overlay');
            var feedback_button = document.getElementById("feedback-button");
            var results_overlay = document.getElementById("ag-output");
            var snapWorld = document.getElementById("world");
            var regrade_buttons = document.getElementsByClassName("regrade");
            
            //var outside_menu = document.getElementById("outside-menu");

            reset_button.onclick = function() { resetState(world, id); toggleMenu(id); };
            revert_button.onclick = function() { revertToBestState(world, id); toggleMenu(id); };
            last_submit.onclick = function() { revertToLastSubmit(world, id); toggleMenu(id); };
            undo_button.onclick = function() { revertToLastState(world, id); toggleMenu(id); };
            menu_button.onclick = function() { toggleMenu(id); };
            //var overlay_button = parent.document.getElementById('overlay-button');
            //overlay_button.onclick = function() { grade_button.click(); }

            $(".bubble").click(function(event){
                event.stopPropagation();  
            });

            feedback_button.onclick = function() {
                openResults();
            }

            help_overlay.onclick = function(e) {
                if (!(document.getElementById('help-popup').contains(e.target))) {
                    closePopup();
                }
            }

            results_overlay.onclick = function(e) {
                if (!(document.getElementById('ag-results').contains(e.target)) && e.target.className.indexOf("regrade") === -1) {
                    closeResults();
                }
            }

            snapWorld.onclick = function(e) {
                if (document.getElementById('dropdown-open') !== null && !(document.getElementById('onclick-menu').contains(e.target))) {
                    toggleMenu();
                }
            }


            /*outside_menu.onclick = function(e) {
                if (document.getElementById('dropdown-open') !== null && !(document.getElementById('onclick-menu').contains(e.target))) {
                    toggleMenu();
                }
            }*/

            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */


            document.addEventListener("click", function() {
                grayOutButtons(world, id);
            });

            if (isEDX) {
                makeOverlayButton();
                var overlay_button = parent.document.getElementById('overlay-button');
                //overlay_button.style.display = "block";
                overlay_button.onclick = function() { 
                    overlay_button.style.display = "none";
                    grade_button.click(); 
                }

                makeFullScreenButton();
                var full_screen = document.getElementById('full-screen');
                full_screen.onclick = function() {
                    toggleSnapWindow(full_screen);   
                }

            }

            IDE_Morph.prototype.originalOpenProject = IDE_Morph.prototype.openProject;
            IDE_Morph.prototype.openProject = function (name) {
                this.originalOpenProject(name);
                setTimeout(function() {
                    runAGTest(world, id);
                }, 500);
                //runAGTest(world, id);
            }

            //TODO: Fix this timeout.
            setTimeout(function() {

                console.log(world);
                var outputLog = AGStart(world,id);
                runAGTest(world, id);
                //runAGTest(world, id);

                /*if (isEDX) {
                    var full_screen = parent.document.getElementById('full-screen');
                    full_screen.onclick = function() {
                        toggleSnapWindow(full_screen);   
                    }
                }*/

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so populateFeedback has to be called twice at the very beginning...
                //populateFeedback(outputLog);
                //populateFeedback(outputLog);
                grayOutButtons(world, id);

                /*$(".regrade").click(function() {
                    var testId = this.classList[2];
                    var test = outputLog[testId];
                    test.graded = false;
                    test.correct = false;
                    outputLog.scoreLog;
                    console.log(outputLog);
                    var mylog = outputLog;
                    //this.classList[2]); 
                });*/

                
                /*for (i=0; i<regrade_buttons.length; i++) {
                    regrade_buttons[i].setAttribute('onclick', 'alert("hello")');
                }*/
                //populateFeedback(outputLog);
                //var outputLog = AGStart(world,id);
                //populateFeedback(outputLog);

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so runAGTest has to be called twice at the very beginning...
                //runAGTest(world,id);
                //runAGTest(world,id);
                //AGUpdate(world, id);

                
            },1000);

            /*var overlay_button = document.createElement('button');
            var overlay_button_text = document.createTextNode('Grade');
            overlay_button.appendChild(overlay_button_text);
            overlay_button.id = 'overlay-button';
            alert(parent.document.getElementsByName('action').length);
            parent.document.getElementsByName('action')[0].appendChild(overlay_button);*/

            //runAGTest(world,id);
            //AGUpdate(world, id);

            setInterval(loop, 1);
            
        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>



<!-- Snap Autograding Button -->
<!--<div id="outside-menu">-->
<div id="autograding_bar">
    <div tabindex="0" class="onclick-menu" id='onclick-menu' style="display:inline-block">
        <span title="Menu">&#9776;</span>
        <div class='hover_darken'></div>
      <nav id="navigation" class="site-navigation" role="navigation">
          <ul id="dropdown-closed" class="bubble">
            <li class="menu-item-sub-menu" id="enabled-button"><a id="feedback-button">View Feedback</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="revert-button">Revert To Best Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="last-submit">Revert To Last edX Submission</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="undo-button">Revert To Last Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="reset-button">Reset</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id='enabled-button' onclick="openPopup();"><a id="help-button">Help</a></li>
          </ul>
    </nav>
    </div>
    <!-- <div id="autograding_flag" style="display:inline-block"></div> -->
    <!-- <div style="display:inline-block"> -->
    <div id="autograding_button" style="display:inline-block;">
        <span></span>
        <div class='hover_darken'></div>
    </div>
    <!-- </div> -->


<!-- Snap Autograding Menu -->

</div>
<!--</div>-->

<!-- Autograding Menu Help Button -->
<!-- <div style="display:inline-block" class="AG-help-button" id="circle" onclick="openPopup();">?
</div> -->
<div class="overlay is-hidden" id="overlay">
    <div class="popup-content" id="help-popup">
        <span class="button-close" onclick="closePopup();">X</span>
            <p>
                Please remember to click the 'Submit' button below the Snap! window to obtain credit for this problem!
            </p>
            <div class="example-ag-buttons" id="ex-ungraded" style="display:inline-block;">
                &#9744;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has not been run yet.
            </p>
            </br>
            <div style="display:inline-block; color: orange;">&#x26A0;</div>
            <div class="example-ag-buttons" id="ex-semigraded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, but there are some errors in the code.
            </p>
            </br>
            <div class="example-ag-buttons" id="ex-graded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, and all the tests have passed!
            </p>
            </br>
    </div>
</div>

<div style="display:inline-block" class="view-results" id="circle" onclick="openResults();">Results
</div>
<div class="overlay is-hidden" id="ag-output">
    <div class="popup-content" id="ag-results">
        <span class="button-close" onclick="closeResults();" id="popup">X</span>
        <p id = "different-feedback"></p>
        <p id = "edx-submit-different"></p>
        <p id="comment"></p>
        <table class="results">
            <tbody id="table-data">
                <tr id="table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
        </br>
        <table class="results">
            <tbody id="reporter-table-data">
                <tr id="reporter-table-titles"> 
                    <!--<th class="titles"> Test </th> 
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
    </div>
</div>


    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
</body>
</html>