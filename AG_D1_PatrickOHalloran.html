<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Snap! Build Your Own Blocks. Beta</title>
    <link rel="shortcut icon" href="favicon.ico">
    <script src="jschannel.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script type="text/javascript">
        var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));
        if (pageLocation) {
            parent.window.scrollTo(pageLocation[0], pageLocation[1]);
            sessionStorage.removeItem("pageLocation");
        }
    </script>
    <script type="text/javascript" src="underscore-min.js"></script>
    <!-- // <script type="text/javascript" src="SnapPLE.js"></script> -->
    <script type="text/javascript" src='gradingLog.js'></script>
    <script type="text/javascript" src='spriteEventLog.js'></script>
    <script type="text/javascript" src='scriptAnalysis.js'></script>
    <meta charset="utf-8">  <!-- This line is needed in order to pass strings into test functions that contain characters
    like "-" and what not. -->
    <!-- Moved down to the bottom to have var id. -->

    <!-- <script type="text/javascript" src="snap.js"></script> -->
    <script type="text/javascript" src="morphic.js"></script>
    <script type="text/javascript" src="widgets.js"></script>
    <script type="text/javascript" src="blocks.js"></script>
    <script type="text/javascript" src="threads.js"></script>
    <script type="text/javascript" src="objects.js"></script>
    <script type="text/javascript" src="gui.js"></script>
    <script type="text/javascript" src="paint.js"></script>
    <script type="text/javascript" src="lists.js"></script>
    <script type="text/javascript" src="byob.js"></script>
    <script type="text/javascript" src="xml.js"></script>
    <script type="text/javascript" src="store.js"></script>
    <script type="text/javascript" src="locale.js"></script>
    <script type="text/javascript" src="cloud.js"></script>
    <script type="text/javascript" src="sha512.js"></script>
<script type="text/javascript" src="snap-edx-overrides.js"></script>

    <link rel="stylesheet" type="text/css" href="AG_status_bar.css" />
    <link rel="stylesheet" type="text/css" href="hintstyle.css" />
    <script type="text/javascript" src="AG_hint_format.js"></script>

    <script type="text/javascript">

        var starter_path = "starter.xml";

        // The id is to act as a course identifier.
        // NOTE: FOR NOW YOU ALSO HAVE TO ADD THE ID TO THE BOTTOM OF THE PAGE.
        var courseID = "";  // e.g. "BJCx"
        // Specify a prerequisite task id, should be null if no such requirement.
        var preReqTaskID = null;
        var preReqID = courseID + preReqTaskID;
        // taskID uniquely identifies the task for saving in browser localStorage.
        var taskID = "AG_D1_T1";
        var id = courseID + taskID;
        var isEDX = isEDXurl();

        // Add tests to the outputLog. Function is called by runAGTest(id, outputLog)
        // var testLog;
        function AGTest(outputLog) {
            /* Lab 1: Introduction */

            /* Getting to Know the Snap! Interface */

                // /* Recreate the move/say/move/say script */
                // var largeScriptExists = function () {
                //     return scriptPresentInSprite('[{"blockSp":"move %n steps","inputs":["20"]},{"blockSp":"say %s for %n secs","inputs":["Hello!","2"]},{"blockSp":"move %n steps","inputs":["20"]},{"blockSp":"say %s for %n secs","inputs":["You\'ve just made a script!","2"]}]');
                // }
                // testAssert(outputLog, largeScriptExists,
                //     "The move/say/move/say script was found on the screen!",
                //     "N/A",
                //     "Make sure you have all of the correct inputs and the blocks are in the correct order!", 1);


                // /* Recreate the move/turn script */
                // var smallScriptExists = function () {
                //     return scriptPresentInSprite('[{"blockSp":"move %n steps","inputs":["10"]},{"blockSp":"turn %clockwise %n degrees","inputs":["15"]}]');
                // }
                // testAssert(outputLog, smallScriptExists,
                //     "The move/turn was found on the screen.",
                //     "N/A",
                //     "Make sure you have all of the correct inputs and the blocks are in the correct order!", 1);

                // /* Recreate pendown/repeat/move/turn */
                // var firstScriptExists = function () {
                //     return scriptPresentInSprite('[{"blockSp":"pen down","inputs":[]},{"blockSp":"repeat %n %c","inputs":["10",[{"blockSp":"move %n steps","inputs":["10"]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]]}]');
                // }
                // testAssert(outputLog, firstScriptExists,
                //     "The penDown/repeat/move/turn block was found on the screen",
                //     "N/A",
                //     "Make sure you recreate the exact script on the screen! Try looking at the exercise again for help!", 1);

        // /* Lab 2: Control Commands. */

            // /* The Forever Block */

            //     /* Recreate provided forever script */
            //     var foreverBlock1 = function () {
            //         return scriptPresentInSprite('[{"blockSp":"forever %c","inputs":[[{"blockSp":"point towards %dst","inputs":["mouse-pointer"]},{"blockSp":"move %n steps","inputs":["1"]}]]}]');
            //     }
            //     testAssert(outputLog, foreverBlock1,
            //         "The script with the for-loop that contains a 'point towards (mouse-pointer)' block and a 'move (1) step' block was found on the screen!",
            //         "N/A",
            //         "One of the scripts is still missing. Double check that the blocks are in the correct order! If you get stuck try also checking the inputs to your blocks and check out the exercise picture for more help!");

            //     var foreverBlock2 = function () {
            //         return scriptPresentInSprite('[{"blockSp":"forever %c","inputs":[[{"blockSp":"go to x: %n y: %n","inputs":["mouse x","mouse y"]}]]}]');
            //     }
            //     testAssert(outputLog, foreverBlock2,
            //         "The script with a for-loop that contains a 'go to x:(mouse x) y:(mouse y)' block has been found on the screen!",
            //         "N/A",
            //         "One of the scripts is still missing. Double check that the blocks are in the correct order! If you get stuck try also checking the inputs to your blocks and check out the exercise picture for more help!");

            //     var foreverBlock3 = function () {
            //         return scriptPresentInSprite('[{"blockSp":"forever %c","inputs":[[{"blockSp":"go to x: %n y: %n","inputs":["x position",{"blockSp":"%n + %n","inputs":["y position","30"]}]}]]}]');
            //     }
            //     testAssert(outputLog, foreverBlock3,
            //         "The script with a for-loop that contains a 'go to x:(x-position) y:(y-position + 30)' block has been found on the screen!",
            //         "N/A",
            //         "One of the scripts is still missing. Double check that the blocks are in the correct order! If you get stuck try also checking the inputs to your blocks and check out the exercise picture for more help!");


        // /* Lab 3: Repeat Commands. */

            /* The For Block */

                // /* Recreate exact squirrel script */
                // var squirrelTest = function () {
                //     return scriptPresentInSprite('[{"blockSp":"pen down","inputs":[]},{"blockSp":"for %upvar = %n to %n %cs","inputs":["1","100",[{"blockSp":"move %n steps","inputs":[{"blockSp":"%n Ã— %n","inputs":["2","length"]}]},{"blockSp":"turn %clockwise %n degrees","inputs":["90"]}]]}]');
                // }
                // testAssert(outputLog, squirrelTest,
                //     "The squiral script was found on the screen.",
                //     "N/A.",
                //     "Double check the image from the exercise to make sure it matches exactly! Make sure the inputs are correct and also make sure the blocks are in the exact order as well!");


        // /* Lab 4: Making your own blocks. */

            /* Making a custom block */

                // /* Create 'draw square' command motion */
                // var sqExists;
                // var squareExists = function () {
                //     var exists = findBlockInPalette("draw square");
                //     if (exists !== null) {
                //         sqExists = true;
                //         return true;
                //     }
                //     sqExists = false;
                //     return false;
                // }
                // testAssert(outputLog, squareExists,
                //     "There is an 'draw square' block.",
                //     "N/A",
                //     "Make sure you name your block exactly 'draw square'.");

                // if (!sqExists) {
                //     return outputLog;
                // }

                // var realSquareBody = getCustomBody("draw square");
                // var containsRepeat = function () {
                //     return scriptContainsBlock(realSquareBody, "repeat % %");
                // }
                // var containsCorrectRepeat = function () {
                //     return scriptContainsBlock(realSquareBody, "repeat % %", ["4", []], true);
                // }
                // var containsMove = function () {
                //     return simpleCBlockContains(realSquareBody, "move % steps", "repeat");
                // }
                // var containsTurn = function () {
                //     return simpleCBlockContains(realSquareBody, "turn %counterclockwise % degrees", "repeat")
                //         || simpleCBlockContains(realSquareBody, "turn %clockwise % degrees", "repeat");
                // }
                // var containsCorrectTurn = function () {
                //     return simpleCBlockContains(realSquareBody, "turn %counterclockwise % degrees", "repeat", ["90"])
                //         || simpleCBlockContains(realSquareBody, "turn %clockwise % degrees", "repeat", ["90"]);
                // }
                // var penDownPresent = function () {
                //     return (spriteContainsBlock("pen down") && !blockPrecedesInSprite("draw square", "pen down")) || blockPrecedes("pen down", "repeat % %", realSquareBody);
                // }

                // testAssert(outputLog, squareExists,
                //     "The 'draw square' block was found in the pallette.",
                //     "N/A",
                //     "Please create the 'draw square %' block.")
                // testAssert(outputLog, containsRepeat,
                //     "The 'repeat' block is found inside 'draw square'.",
                //     "N/A",
                //     "One approach is to try placing a repeat block inside of the definition. Hopefully that helps!");

                // testAssert(outputLog, containsCorrectRepeat,
                //     "The 'repeat' block has a counter of 4.",
                //     "N/A",
                //     "If you're having trouble about what to put into the input for the repeat, try thinking about how many times we would the command blocks to repeat so we can get a square!");

                // testAssert(outputLog, containsMove,
                //     "The 'draw square' block contains move inside of the repeat loop.",
                //     "N/A",
                //     "If your sprite is not moving across the stage, what block can we use to do that? Hint: the block is in the blue tab");

                // testAssert(outputLog, containsTurn,
                //     "The 'draw square' block contains a turn block.",
                //     "N/A",
                //     "If your sprite is only going striaght, we need to fix that. How can we redirect the spite's direction? Hint: the block is in the blue tab!");

                // testAssert(outputLog, containsCorrectTurn,
                //     "The 'draw square' block contains turn block with 90 degrees.",
                //     "N/A",
                //     "If your sprite is turning at weird angles, think of the internal angles of a square. That is how much we need to turn by.");

                // testAssert(outputLog, penDownPresent,
                //     "The 'draw square' block contains the 'pen down' block.",
                //     "N/A",
                //     "If the sprite is not drawing anything, it could be because we are missing a certain block. Hint: in the teal pen tab!");

                // /* Create 'draw triangle' command block */
                // var triExists;
                // var triangleExists = function () {
                //     var exists = findBlockInPalette("draw triangle");
                //     if (exists !== null) {
                //         triExists = true;
                //         return true;
                //     }
                //     triExists = false;
                //     return false;
                // }
                // testAssert(outputLog, triangleExists,
                //     "There is an 'draw triangle' block.",
                //     "N/A",
                //     "Make sure you name your block exactly 'draw triangle'.");

                // if (!triExists) {
                //     return outputLog;
                // }
                // var realTriangleBody = getCustomBody("draw triangle");
                // var trianglePresent = function () {
                //     return spriteContainsBlock("draw triangle");
                // }
                // var containsRepeat = function () {
                //     return scriptContainsBlock(realTriangleBody, "repeat % %");
                // }
                // var containsCorrectRepeat = function () {
                //     return scriptContainsBlock(realTriangleBody, "repeat % %", ["3", []], true);
                // }
                // var containsMove = function () {
                //     return simpleCBlockContains(realTriangleBody, "move % steps", "repeat");
                // }
                // var containsTurn = function () {
                //     return simpleCBlockContains(realTriangleBody, "turn %counterclockwise % degrees", "repeat")
                //         || simpleCBlockContains(realTriangleBody, "turn %clockwise % degrees", "repeat");
                // }
                // var containsCorrectTurn = function () {
                //     return simpleCBlockContains(realTriangleBody, "turn %counterclockwise % degrees", "repeat", ["120"])
                //         || simpleCBlockContains(realTriangleBody, "turn %clockwise % degrees", "repeat", ["120"]);
                // }
                // var penDownPresent = function () {
                //     return (spriteContainsBlock("pen down") && !blockPrecedesInSprite("draw triangle", "pen down")) || blockPrecedes("pen down", "repeat % %", realTriangleBody);
                // }

                // testAssert(outputLog, trianglePresent,
                //     "The 'draw triangle' block was found in the pallette.",
                //     "N/A",
                //     "Please create the 'draw triangle' block.")

                // testAssert(outputLog, containsRepeat,
                //     "The 'repeat' block is found inside 'draw triangle'.",
                //     "N/A",
                //     "If you're getting stuck, try using a repeat block!");

                // testAssert(outputLog, containsCorrectRepeat,
                //     "The 'repeat' block has a counter of 3.",
                //     "N/A",
                //     "If we want to repeat the commands inside of a repeat, how many times should we do so for a triangle to be created?");

                // testAssert(outputLog, containsMove,
                //     "The 'draw triangle' block contains move inside of the repeat loop.",
                //     "N/A",
                //     "We need to sprite to move, how can we do so? Hint: the blue tab!");

                // testAssert(outputLog, containsTurn,
                //     "The 'draw triangle' block contains a turn block.",
                //     "N/A",
                //     "If the sprite isn't changing directions, we need to fix that. Look in the blue tab for a helpful block!");

                // testAssert(outputLog, containsCorrectTurn,
                //     "The 'draw triangle' block contains turn block with 120 degrees.",
                //     "N/A",
                //     "When turning, how much do we need to turn? Try drawing out a triangle and think about the turning degree. ");

                // testAssert(outputLog, penDownPresent,
                //     "The 'draw triangle' block contains the 'pen down' block.",
                //     "N/A",
                //     "If the sprite is not drawing anything, it could be because we are missing a certain block. Hint: in the teal pen tab!");

                // /* Create 'draw house' command block */
                // var houseExists;
                // var drawHouseExists = function () {
                //     var housefound = findBlockInPalette("draw house");
                //     if (housefound !== null) {
                //         houseExists = true;
                //         return true;
                //     }
                //     houseExists = false;
                //     return false;
                // }
                // testAssert(outputLog, drawHouseExists,
                //     "There is an 'draw house' block.",
                //     "N/A",
                //     "Make sure you name your block exactly 'draw house'.");

                // if (!houseExists) {
                //     return outputLog;
                // }
                // var realHouseBody = getCustomBody("draw house");
                // var housePresent = function () {
                //     return spriteContainsBlock("draw house");
                // }
                // var trianglePresent = function () {
                //     return  occurancesOfBlockSpec("draw triangle", realHouseBody) === 1;
                // }
                // var squarePresent = function () {
                //     return occurancesOfBlockSpec("draw square", realHouseBody) === 1;
                // }
                // var penDownPresent = function () {
                //     return (spriteContainsBlock("pen down") && !blockPrecedesInSprite("draw house", "pen down")) || ((blockPrecedes("pen down", "draw square", realHouseBody)) && (blockPrecedes("pen down", "draw triangle", realHouseBody)));
                // }

                // testAssert(outputLog, trianglePresent,
                //     "The 'draw house' block contains the 'draw triangle' block.",
                //     "N/A",
                //     "Try using previously made blocks inside the body of 'draw house' to draw the roof!");

                // testAssert(outputLog, squarePresent,
                //     "The 'draw house' block contains the 'draw square' block.",
                //     "N/A",
                //     "Try using previously made blocks inside the body of 'draw house' to draw the rest of the house!");

                // testAssert(outputLog, penDownPresent,
                //     "The 'draw house' block contains the 'pen down' block.",
                //     "N/A",
                //     "If the sprite is not drawing anything, it could be because we are missing a certain block. Hint: in the teal pen tab!");

            // /* Composition of Blocks */

                // /* Create "draw square-petal flower with % petals of size %" motion command block */
                // var flowerExists;
                // var drawFlowerExists = function () {
                //     var flowerFound = findBlockInPalette("draw house");
                //     if (flowerFound !== null) {
                //         flowerExists = true;
                //         return true;
                //     }
                //     flowerExists = false;
                //     return false;
                // }
                // testAssert(outputLog, drawFlowerExists,
                //     "There is a 'draw square-petal flower with % petals of size %' block.",
                //     "N/A",
                //     "Make sure you name your block exactly 'draw square-petal flower with % petals of size %'.");

                // if (!flowerExists) {
                //     return outputLog;
                // }
                // var realFlowerBody = getCustomBody("draw square-petal flower with % petals of size %");
                // var realFlowerParameters = JSONcustomBlock(findBlockInPalette("draw square-petal flower with % petals of size %")).variables;
                // var containsRepeat = function () {
                //     return scriptContainsBlock(realFlowerBody, "repeat % %");
                // }
                // var containsCorrectRepeat = function () {
                //     return scriptContainsBlock(realFlowerBody, "repeat % %", [realFlowerParameters[0], []], true);
                // }
                // var containsDrawSquare = function () {
                //     return simpleCBlockContains(realFlowerBody, "draw square %", "repeat");
                // }
                // var containsCorrectDrawSquare = function () {
                //     return simpleCBlockContains(realFlowerBody, "draw square %", "repeat", [realFlowerParameters[1]]);
                // }
                // var containsTurn = function () {
                //     return simpleCBlockContains(realFlowerBody, "turn %counterclockwise % degrees", "repeat")
                //         || simpleCBlockContains(realFlowerBody, "turn %clockwise % degrees", "repeat");
                // }
                // var containsCorrectTurn = function () {
                //     var turnDegree = (360 / parseInt(realFlowerParameters[0])).toString();
                //     console.log(turnDegree);
                //     return simpleCBlockContains(realFlowerBody, "turn %counterclockwise % degrees", "repeat", [turnDegree])
                //         || simpleCBlockContains(realFlowerBody, "turn %clockwise % degrees", "repeat", [{"blockSp":"%n / %n","inputs":["360","numPetals"]}]);
                // }
                // var penDownPresent = function () {
                //     return (spriteContainsBlock("pen down") && !blockPrecedesInSprite("draw square-petal flower with % petals of size %", "pen down")) || (blockPrecedes("pen down", "repeat % %", realFlowerBody));
                // }

                // testAssert(outputLog, containsRepeat,
                //     "The 'repeat' block is found inside 'draw square-petal flower with % petals of size %'.",
                //     "N/A",
                //     "If you are stuck try using a repeat inside of 'draw square-petal flower with % petals of size %'");

                // testAssert(outputLog, containsCorrectRepeat,
                //     "The 'repeat' block has a counter of the number of petals.",
                //     "N/A",
                //     "How many times should we repeat to draw a flower?");

                // testAssert(outputLog, containsDrawSquare,
                //     "The 'draw square-petal flower with % petals of size %' block contains 'draw square %' inside of the repeat loop.",
                //     "N/A",
                //     "What blocks helps move the sprite?");

                // testAssert(outputLog, containsCorrectDrawSquare,
                //     "The 'draw square-petal flower with % petals of size %' block contains the correct 'draw square %' inside of the repeat loop.",
                //     "N/A",
                //     "How big are the petals supposed to be supposed to be?");

                // testAssert(outputLog, containsTurn,
                //     "The 'draw square-petal flower with % petals of size %' block contains a turn block.",
                //     "N/A",
                //     "We need to redirect the sprite's motion. How can we do this? Hint: the blue motion tab!");

                // testAssert(outputLog, containsCorrectTurn,
                //     "The 'draw square-petal flower with % petals of size %' block contains turn block with 360/numberOfPetals degrees.",
                //     "N/A",
                //     "Try using a turn block, how many degrees should we turn?");

                // testAssert(outputLog, penDownPresent,
                //     "The 'draw triangle' block contains the 'pen down' block.",
                //     "N/A",
                //     "If the sprite isn't drawing anything, try looking in the teal pen tab!");


                // /* Draw triangle, pentagon, hexagon, octagon scripts (The Polygons)*/
                // var repeatSpec = "repeat % %";
                // var turnClockwiseSpec = "turn %clockwise % degrees";
                // var turnCounterClockwiseSpec = "turn %counterclockwise % degrees";
                // var emptyInputs = [];
                
                // var triangleRepeatInputs = ["3", []];
                // var triangleTurnInputs = ["120"];
                
                // var pentagonRepeatInputs = ["5", []];
                // var pentagonTurnInputs = ["72"];
                
                // var hexagonRepeatInputs = ["6", []];
                // var hexagonTurnInputs = ["60"];
                
                // var octagonRepeatInputs = ["8", []];
                // var octagonTurnInputs = ["45"];

                // //Begin triangle
                // var trianglePresent = false;
                // var triangleHasCorrectRepeat = function () {
                //     var result = spriteContainsBlock("repeat % %", 0, triangleRepeatInputs, true);
                //     if (result) {
                //         trianglePresent = true;
                //     }
                //     return result;
                // }
                // var triangleHasTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, emptyInputs, triangleRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, emptyInputs, triangleRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }
                // var triangleHasCorrectTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, triangleTurnInputs, triangleRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, triangleTurnInputs, triangleRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }

                // testAssert(outputLog, triangleHasCorrectRepeat,
                //     "The script for the triangle has the correct counter 3 for the repeat loop",
                //     "N/A",
                //     "Try thinking about how we can use the repeat loop. How many times should the commands in the body of the repeat block be repeated?");
                // if (trianglePresent) {
                //     testAssert(outputLog, triangleHasTurn,
                //     "The script for drawing a triangle has a turn block.",
                //     "N/A",
                //     "Which block can we use to help the sprite change direction?");
                // testAssert(outputLog, triangleHasCorrectTurn,
                //     "The script for drawing a triangle has the correct turn of 120 degrees",
                //     "N/A",
                //     "Try thinking about the internal angles of a triangle. How much do we need to turn? How many times should we do this?");
                // }

                // //Begin Pentagon
                // var pentagonPresent = false;
                // var pentagonHasCorrectRepeat = function () {
                //     var result = spriteContainsBlock("repeat % %", 0, pentagonRepeatInputs, true);
                //     if (result) {
                //         pentagonPresent = true;
                //     }
                //     return result;
                // }
                // var pentagonHasTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, emptyInputs, pentagonRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, emptyInputs, pentagonRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }
                // var pentagonHasCorrectTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, pentagonTurnInputs, pentagonRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, pentagonTurnInputs, pentagonRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }

                // testAssert(outputLog, pentagonHasCorrectRepeat,
                //     "The script for the pentagon has the correct counter 5 for the repeat loop",
                //     "The script for the pentagon does not have the correct counter for the repeat loop. How many times should we repeat the commands that occur within the repeat loop?",
                //     "Try thinking about how we can use the repeat loop. How many times should the commands in the body of the repeat block be repeated?");
                // if (pentagonPresent) {
                //     testAssert(outputLog, pentagonHasTurn,
                //     "The script for drawing a pentagon has a turn block.",
                //     "The script for drawing a pentagon is not changing direction, how can we fix this?",
                //     "Which block can we use to help the sprite change direction?");
                // testAssert(outputLog, pentagonHasCorrectTurn,
                //     "The script for drawing a pentagon has the correct turn of 72 degrees",
                //     "The script for drawing a pentagon has incorrect turning radius. How much do we need to turn by for each turn?",
                //     "Try thinking about the internal angles of a pentagon. How much do we need to turn? How many times should we do this?");
                // }

                // //Begin hexagon
                // var hexagonPresent = false;
                // var hexagonHasCorrectRepeat = function () {
                //     var result = spriteContainsBlock("repeat % %", 0, hexagonRepeatInputs, true);
                //     if (result) {
                //         hexagonPresent = true;
                //     }
                //     return result;
                // }
                // var hexagonHasTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, emptyInputs, hexagonRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, emptyInputs, hexagonRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }
                // var hexagonHasCorrectTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, hexagonTurnInputs, hexagonRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, hexagonTurnInputs, hexagonRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }

                // testAssert(outputLog, hexagonHasCorrectRepeat,
                //     "The script for the hexagon has the correct counter 6 for the repeat loop",
                //     "The script for the hexagon does not have the correct counter for the repeat loop. How many times should we repeat the commands that occur within the repeat loop?",
                //     "Try thinking about how we can use the repeat loop. How many times should the commands in the body of the repeat block be repeated?");
                // if (hexagonPresent) {
                //     testAssert(outputLog, hexagonHasTurn,
                //     "The script for drawing a hexagon has a turn block.",
                //     "The script for drawing a hexagon is not changing direction, how can we fix this?",
                //     "Which block can we use to help the sprite change direction?");
                // testAssert(outputLog, hexagonHasCorrectTurn,
                //     "The script for drawing a hexagon has the correct turn of 60 degrees",
                //     "The script for drawing a hexagon has incorrect turning radius. How much do we need to turn by for each turn?",
                //     "Try thinking about the internal angles of a hexagon. How much do we need to turn? How many times should we do this?");
                // }

                // //Begin octagon
                // var octagonPresent = false;
                // var octagonHasCorrectRepeat = function () {
                //     var result = spriteContainsBlock("repeat % %", 0, octagonRepeatInputs, true);
                //     if (result) {
                //         octagonPresent = true;
                //     }
                //     return result;
                // }
                // var octagonHasTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, emptyInputs, octagonRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, emptyInputs, octagonRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }
                // var octagonHasCorrectTurn = function () {
                //     var withClockwise = CBlockContainsInSprite(turnClockwiseSpec, repeatSpec, 0, octagonTurnInputs, octagonRepeatInputs);
                //     var withCounterClockwise = CBlockContainsInSprite(turnCounterClockwiseSpec, repeatSpec, 0, octagonTurnInputs, octagonRepeatInputs);
                //     return withClockwise || withCounterClockwise;
                // }

                // testAssert(outputLog, octagonHasCorrectRepeat,
                //     "The script for the octagon has the correct counter 8 for the repeat loop",
                //     "The script for the octagon does not have the correct counter for the repeat loop. How many times should we repeat the commands that occur within the repeat loop?",
                //     "Try thinking about how we can use the repeat loop. How many times should the commands in the body of the repeat block be repeated?");

                // if (octagonPresent) {
                //     testAssert(outputLog, octagonHasTurn,
                //         "The script for drawing a octagon has a turn block.",
                //         "The script for drawing a octagon is not changing direction, how can we fix this?",
                //         "Which block can we use to help the sprite change direction?");
                //     testAssert(outputLog, octagonHasCorrectTurn,
                //         "The script for drawing a octagon has the correct turn of 45 degrees",
                //         "The script for drawing a octagon has incorrect turning radius. How much do we need to turn by for each turn?",
                //         "Try thinking about the internal angles of a octagon. How much do we need to turn? How many times should we do this?");
                // }


        // /* BEGIN UNIT 2 STUFF */
            // /*Tests for 'vowel? %letter' predicate block*/
            // var vowelExists = function () {
            //     var vowelFound = findBlockInPalette("vowel? %");
            //     if (vowelFound !== null) {
            //         return true;
            //     }
            //     return false;
            // }

            // var hasIfStatements = function () {
            //     return customBlockContains("vowel? %", "if % %", [], 0, true);
            // }

            // testAssert(outputLog, vowelExists,
            //     "There is a 'vowel? %' block.",
            //     "N/A",
            //     "Make sure you create and name your block exactly 'vowel? %'.");
            // testAssert(outputLog, hasIfStatements,
            //     "There is a 'if % %' block in the definition.",
            //     "N/A",
            //     "Try using one of the conditional blocks in the yellow control tab to handle the vowels! What do we need to do about the consonants?");

            // multiTestBlock(outputLog, 'vowel? %',
            //     [["p"], ["a"], ["e"], ["i"], ["o"], ["u"], ["y"], ["f"]], //inputs
            //     [false, true, true, true, true, true, false, false], //expected outputs
            //     [-1, -1, -1, -1, -1, -1, -1, -1], //timeouts
            //     [true, true, true, true, true, true, true, true]); //Boolean stuff

            // /* Line 50 (recreate forever and repeat until scripts) test in excel doc */
            // var foreverScriptPresent = function () {
            //     return scriptPresentInSprite('[{"blockSp":"forever %c","inputs":[[{"blockSp":"if %b %c else %c","inputs":[{"blockSp":"%s = %s","inputs":[{"blockSp":"%n mod %n","inputs":["direction","60"]},"0"]},[{"blockSp":"set pen size to %n","inputs":["5"]}],[{"blockSp":"set pen size to %n","inputs":["1"]}]]},{"blockSp":"move %n steps","inputs":["1"]},{"blockSp":"turn %clockwise %n degrees","inputs":["1"]}]]}]');
            // }

            // testAssert(outputLog, foreverScriptPresent,
            //     "The forever script was found.",
            //     "The forever script was not found. Look at the lab exercise for more guidance.",
            //     "Please try to match the script exactly as shown in the exercise.");

            // var repeatUntilScriptPresent = function () {
            //     return scriptPresentInSprite('[{"blockSp":"repeat until %b %c","inputs":[{"blockSp":"%s > %s","inputs":["direction","180"]},[{"blockSp":"if %b %c else %c","inputs":[{"blockSp":"%s = %s","inputs":[{"blockSp":"%n mod %n","inputs":["direction","45"]},"0"]},[{"blockSp":"set pen color to %clr","inputs":[]},{"blockSp":"set pen size to %n","inputs":["5"]}],[{"blockSp":"set pen color to %clr","inputs":[]},{"blockSp":"set pen size to %n","inputs":["1"]}]]},{"blockSp":"move %n steps","inputs":["1"]},{"blockSp":"turn %clockwise %n degrees","inputs":["1"]}]]},{"blockSp":"repeat until %b %c","inputs":[{"blockSp":"%s = %s","inputs":["direction","0"]},[{"blockSp":"move %n steps","inputs":["1"]},{"blockSp":"turn %clockwise %n degrees","inputs":["1"]}]]}]');
            // }

            // testAssert(outputLog, repeatUntilScriptPresent,
            //     "The repeat until script was found.",
            //     "The repeat until script was not found. Please try to match the script exactly as shown in the exercise.",
            //     "Please try to match the script exactly as shown in the exercise.");

            // /* Line 61 recreate random polygon drawer */
            // var randomPolygonPresent = function () {
            //     return scriptPresentInSprite('[{"blockSp":"when %greenflag clicked","inputs":[]},{"blockSp":"script variables %scriptVars","inputs":[]},{"blockSp":"set %var to %s","inputs":["sides",{"blockSp":"pick random %n to %n","inputs":["3","10"]}]},{"blockSp":"clear","inputs":[]},{"blockSp":"pen down","inputs":[]},{"blockSp":"repeat %n %c","inputs":["sides",[{"blockSp":"move %n steps","inputs":["50"]},{"blockSp":"turn %clockwise %n degrees","inputs":[{"blockSp":"%n / %n","inputs":["360","sides"]}]}]]}]');
            // }

            // testAssert(outputLog, randomPolygonPresent,
            //     "The random polygon script is present.",
            //     "N/A",
            //     "Please look at the exercise image to recreate the exact script.");

            /* Line 67 create the number-of-divisors */
            // //Number-of-divisors: Make sure you create and name your block exactly 'number-of-divisors %'.
            // var funcBody = getCustomBody("number-of-divisors %");
            // var numberOfDivisorsExists = function () {
            //     var numberOfDivisorsFound = findBlockInPalette("number-of-divisors %");
            //     if (numberOfDivisorsFound !== null) {
            //         return true;
            //     }
            //     return false;
            // }

            // var containsForLoop = function () {
            //     return scriptContainsBlock(funcBody, "for % = % to % %");
            // }
            // var containsMod = function () {
            //     return scriptContainsBlock(funcBody, "% mod %");
            // }
            // var containsScriptVars = function () {
            //     return scriptContainsBlock(funcBody, "script variables %");
            // }


            // testAssert(outputLog, numberOfDivisorsExists,
            //     "There is a 'number-of-divisors %' block.",
            //     "N/A",
            //     "Make sure you create and name your block exactly 'number-of-divisors %'.");
            // testAssert(outputLog, containsForLoop,
            //     "There is a for-loop inside the definition.",
            //     "N/A",
            //     "If you are stuck on trying to figure out how to check every value, try a for-loop!");
            // testAssert(outputLog, containsMod,
            //     "There is a mod block inside the definition.",
            //     "N/A",
            //     "If you are stuck on trying to figure out how to check if a given number divides your input, try using the mod block!");
            // testAssert(outputLog, containsScriptVars,
            //     "There is a script variables block inside the definition.",
            //     "N/A",
            //     "If you are stuck on trying to figure out how to keep a running count of how the total number of divisors, try using a script variable!");

            // // Number-of-divisors: Make sure your function works for positive numbers!
            // multiTestBlock(outputLog, 'number-of-divisors %',
            //     [[8], [11], [3]],
            //     [4, 2, 2],
            //     [-1, -1, -1],
            //     [true, true, true]);

            // /* Line 68 create the 'digital sum' block */
            // //Digital sum: make sure create and name your block exactly 'digital sum %'
            // var funcBody = getCustomBody("digital sum %");
            // var digitalSumExists = function () {
            //     var digitalSumFound = findBlockInPalette("digital sum %");
            //     if (digitalSumFound !== null) {
            //         return true;
            //     }
            //     return false;
            // }
            // var containsForLoop = function () {
            //     return scriptContainsBlock(funcBody, "for % = % to % %");
            // }
            // var containsScriptVars = function () {
            //     return scriptContainsBlock(funcBody, "script variables %");
            // }
            // testAssert(outputLog, digitalSumExists,
            //     "There is a 'digital sum %' block.",
            //     "N/A",
            //     "Make sure you create and name your block exactly 'digital sum %'.");
            // testAssert(outputLog, containsForLoop,
            //     "There is a for-loop inside the definition.",
            //     "N/A",
            //     "If you are stuck on trying to figure out how to iterate through every digit, try a for-loop!");
            // testAssert(outputLog, containsScriptVars,
            //     "There is a script variables block inside the definition.",
            //     "N/A",
            //     "If you are stuck on trying to figure out how to keep a running count of the total digital sum, try using a script variable!");

            // multiTestBlock(outputLog, 'digital sum %',
            //     [[55], [123], [1003]],
            //     [10, 6, 4],
            //     [-1, -1, -1],
            //     [true, true, true]);

            

            // /* Line 69 create the 'multiples of 7 algorithm' block */
            // //multiples of 7 algorithm: make sure create and name your block exactly 'multiples of 7 algorithm %'
            // var multiplesOf7Exists = function () {
            //     var multiplesOf7Found = findBlockInPalette("multiples of 7 algorithm %");
            //     if (multiplesOf7Found !== null) {
            //         return true;
            //     }
            //     return false;
            // }
            // var multiplesOf7Body = getCustomBody('multiples of 7 algorithm %');
            // var notContainsModBlock = function () {
            //     if (multiplesOf7Body === undefined) {
            //         return false;
            //     }
            //     var modBlockFound = scriptContainsBlock(multiplesOf7Body, '% mod %');
            //     if (modBlockFound) {
            //         return false;
            //     }
            //     return true;
            // }
            // var containsScriptVars = function () {
            //     return scriptContainsBlock(multiplesOf7Body, "script variables %");
            // }

            // testAssert(outputLog, multiplesOf7Exists,
            //     "There is a 'multiples of 7 algorithm %' block.",
            //     "N/A",
            //     "Make sure you create and name your block exactly 'multiples of 7 algorithm %'.");

            // testAssert(outputLog, notContainsModBlock,
            //     "There is a not '% mod %' block inside the definition of 'multiples of 7 algorithm %'.",
            //     "N/A",
            //     "Try making the function without using a '% mod %' block. A repeat-until block sounds like it could work. Also look at the blocks on the screen in the exercise that we suggest.");
            // testAssert(outputLog, containsScriptVars,
            //     "There is a script variables block inside the definition.",
            //     "N/A",
            //     "If you are stuck on trying to figure out how to keep track of the digits, try using script variables!");

            // //Make sure your function works for numbers greater than 21!
            // multiTestBlock(outputLog, 'multiples of 7 algorithm %',
            //     [[501298], [28], [23], [35]],
            //     [-14, -14, -4, -7],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            // //multiples of 7 algorithm: Make sure your function works for 21!
            // multiTestBlock(outputLog, 'multiples of 7 algorithm %',
            //     [[21]],
            //     [0],
            //     [-1],
            //     [true]);

            // //multiples of 7 algorithm %: Make sure your function works for numbers less than 21!
            // multiTestBlock(outputLog, 'multiples of 7 algorithm %',
            //     [[14], [10], [-4], [-90]],
            //     [14, 10, -4, -90],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            // /* Line 97 Three-input addition block */
            // //Three-input add: Make sure you create a function exactly named: '% + % + %'
            // var add3Exists = function () {
            //     var add3Found = findBlockInPalette("% + % + %");
            //     if (add3Found !== null) {
            //         return true;
            //     }
            //     return false;
            // }
            // var sumExists = function () {
            //     var customBody = getCustomBody("% + % + %");
            //     var sumFound = scriptContainsBlock(customBody, "% + %");
            //     return sumFound;
            // }
            // testAssert(outputLog, add3Exists,
            //     "There is a three-input add block.",
            //     "N/A",
            //     "Please make a block that looks like exercise 1 among the above exercises.");
            // testAssert(outputLog, sumExists,
            //     "There is a '% + %' block inside of the body of the three-input add block.",
            //     "N/A",
            //     "We need to add three numbers. Try using the '% + % block in composing your function!");

            // //'% + % + %': Make sure your function works for general cases!
            // multiTestBlock(outputLog, '% + % + %',
            //     [[10, 2, 5], [-10, -2, 6], [0, 0, 0], [100, -1000, 0]],
            //     [17, -6, 0, -900],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);

            // /* Line 98 Sum of two smallest block */
            // // Sum of two smallest: Make sure you create a function exactly named: 'sum of two smallest % and % and %'
            // var sumOfTwoSmallestExists = function () {
            //     var sumOfTwoSmallestFound = findBlockInPalette("sum of two smallest % and % and %");
            //     if (sumOfTwoSmallestFound !== null) {
            //         return true;
            //     }
            //     return false;
            // }
            // var customBody = getCustomBody('sum of two smallest % and % and %');
            // var useMaxBlock = function () {
            //     var maxBlockFound = scriptContainsBlock(customBody, "max of % and %");
            //     return maxBlockFound;
            // }
            // var useDifferenceBlock = function () {
            //     return scriptContainsBlock(customBody, "% âˆ’ %");
            // }
            // var useTripleSumBlock = function () {
            //     return scriptContainsBlock(customBody, "% + % + %");
            // }
            // testAssert(outputLog, sumOfTwoSmallestExists,
            //     "There is a sum of two smallest block.",
            //     "N/A",
            //     "Please make a block that looks like exercise 2 among the above exercises.");
            // testAssert(outputLog, useMaxBlock,
            //     "Uses a max block in the definition of the function.",
            //     "N/A",
            //     "Try using the max block we made in a previous exercise!");
            // testAssert(outputLog, useDifferenceBlock,
            //     "Uses a difference block in the definition of the function.",
            //     "N/A",
            //     "One way to approach this problem is thinking about each number as part of a whole. Can we take out something from that whole? What block would be helpful in that?");
            // testAssert(outputLog, useTripleSumBlock,
            //     "Uses a triple sum block in the definition of the function.",
            //     "N/A",
            //     "One way to approach this problem is thinking about each number as part of a whole. How can we construct that whole using a block we have already made? Which block would be useful that takes in three numbers?");

            // //'sum of two smallest % and % and %': Make sure your function works for general cases!
            // multiTestBlock(outputLog, 'sum of two smallest % and % and %',
            //     [[10, 2, 5], [-10, -2, 6], [0, 0, 0], [100, -1000, 0]],
            //     [7, -12, 0, -1000],
            //     [-1, -1, -1, -1],
            //     [true, true, true, true]);




            return outputLog;

        }

        /* Removes the previously saved AG_state. Runs the tests in
         * AGTest().
         * Called by 'click' event on autograder_button.
         */
        function runAGTest(snapWorld, taskID, outputLog) {
            // Create a new gradingLog if none is specified.
            var numAttempts = setNumAttempts(taskID);
            outputLog = outputLog || new gradingLog(snapWorld, taskID, numAttempts);
            // Populate, run, and evaluate the tests specified in AGTest()
            // These tests specified by the Course Designer.

            //outputLog.numAttempts += 1;

            var test_log = AGTest(outputLog);
            if(!test_log.runSnapTests()) {
                outputLog.scoreLog();
            }
        }

        /* After loading the XML, check if the current XML is a known
         * state, restore the gradingLog if it is.
         * @return {gradingLog}
         * TODO: Trigger AGStart when a Snap file is loaded.
         */
        function AGStart(snapWorld, taskID) {
            //Grab HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var outputLog;
            //If the current XML matches the stored correct XML
            if (isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_c_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);
                return outputLog;
            }
            //If the current XML matches the last stored gradingLog
            if (isSameSnapXML(prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state
                var outputLog = JSON.parse(localStorage.getItem(taskID + "_test_log"));
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                return outputLog;
            } else {
                //Restore the AG status bar to a graded state
                //If no previous state is recognized, return new {gradingLog}.
                var numAttempts = setNumAttempts(taskID);
                outputLog = new gradingLog(snapWorld, taskID, numAttempts);
                AG_bar_ungraded(outputLog);
                return outputLog;
            }
        }
        /* Checks to see if the Snap! XML has changed and updates the
         * AG status bar. If Snap! is restored to its former state
         * the grading log and status bar are also restored.
         * @return {gradingLog} outputLog
         * Note:
         *  - Should only be called from a "mouseup" event.
         */
        function AGUpdate(snapWorld, taskID) {



            //TODO: Are there any optional parameters that may be useful?
            //Grabs HTML divs
            var menu_button = document.getElementById("onclick-menu");
            var grade_button = document.getElementById("autograding_button");
            //Get the current Snap XML string
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            //Retrieve previous grade logs (if in localStorage). As {String}s
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (!prev_xml || !curr_xml) {
                console.log(prev_xml);
                console.log(curr_xml);
            }
            //menu bar grays out options that are not available
            //(ex. current state is same as best attempt) and restores the button state
            grayOutButtons(snapWorld, taskID);
            var outputLog;
            //If current XML is different from prev_xml
            if (c_prev_xml && isSameSnapXML(c_prev_xml, curr_xml)) {
                //Restore the AG status bar to a graded state

                // TODO: Write a good comment
                // TODO: Give gradeLog ability to recover log data and xml string
                console.log('AGUpdate: Thinks this is the "correct" XML.');
                localStorage.setItem(taskID + "_test_log", c_prev_log);
                localStorage.setItem(taskID + "_test_state", curr_xml);
                document.getElementById("different-feedback").innerHTML = "";

                //Retrieve the correct test log from localStorage
                outputLog = JSON.parse(c_prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_graded(outputLog);

                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "none";
                }

            } else if (prev_xml && isSameSnapXML(prev_xml, curr_xml, true)) {
                //Restore the AG status bar to a graded state
                console.log('AGUpdate: Thinks this is just the "last" XML.');
                //Retrieve the previous test log from localStorage
                document.getElementById("different-feedback").innerHTML = "";

                outputLog = JSON.parse(prev_log);
                outputLog.snapWorld = snapWorld;
                AG_bar_semigraded(outputLog);
                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "none";
                }

            } else {
                //Restore the AG status bar to a graded state
                var numAttempts = setNumAttempts(taskID);
                outputLog = new gradingLog(snapWorld, taskID, numAttempts);
                //outputLog = JSON.parse(prev_log);
                //outputLog.snapWorld = snapWorld;
                AG_bar_ungraded(outputLog);
                document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
                if (isEDX) {
                    parent.document.getElementById('overlay-button').style.display = "block";
                }

            }
            //populateFeedback(outputLog);
            return outputLog;

        }

        /* Updates the AG_status_bar with respect to the outputLog.
         *  - Formats CSS for 'autograding_flag' and 'autograding_button'
         * If the outputLog is correct, save the Snap XML string into
         * localStorage.
         *  - key = outputLog.taskID + "_c_test_state"
         * Note:
         *  - Should only be called from outputLog.evaluateLog()
         */
        function AGFinish(outputLog) {
            // Verify correctness
            if (outputLog.allCorrect) {
                // Save the correct XML string into localStorage
                AG_bar_graded(outputLog);
                outputLog.saveSnapXML(outputLog.taskID + "_c_test_state");
            } else {
                // Update AG_status_bar to 'graded, but incorrect state
                AG_bar_semigraded(outputLog);
            }
            //Save the current XML. Log is saved in gradingLog.scoreLog(...)
            outputLog.saveSnapXML(outputLog.taskID + "_test_state");
            //outputLog.numAttempts += 1;
            populateFeedback(outputLog);
            grayOutButtons(outputLog.snapWorld, outputLog.taskID);
            console.log('Autograder test Results:');
            console.log(outputLog);
            //populateFeedback(outputLog);
            if (isEDX) {
                parent.document.getElementsByClassName('check-label')[0].click();
            }
            //parent.document.getElementsByClassName('check-label')[0].click();
        }
        /*
         * Reset state removes all saved logs and XML files, and opens a new
         * Snap! file.
         */
        function resetState(snapWorld, taskID) {

            var numAttempts = JSON.parse(localStorage.getItem(taskID + "_test_log")).numAttempts;

            localStorage.removeItem(taskID + "_test_log");
            localStorage.removeItem(taskID + "_test_state");
            localStorage.removeItem(taskID + "_c_test_log");
            localStorage.removeItem(taskID + "_c_test_state");

            var ide = snapWorld.children[0];

            if (starter_path) {
                $.get(starter_path, function(data) {
                ide.openProjectString(data)},
                "text");
            } else {
                ide.newProject();
            }
            var new_log = AGStart(snapWorld, taskID);
            new_log.numAttempts = numAttempts;
            //localStorage.setItem(taskID + "_test_log", new_log);
            localStorage.setItem(taskID + "_test_state", ide.serializer.serialize(ide.stage));
            new_log.saveLog();
            //localStorage.setItem(taskID + "_test_log", new_log);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToBestState(snapWorld, taskID) {

            var ide = snapWorld.children[0];

            var numAttempts = JSON.parse(localStorage.getItem(taskID + "_test_log")).numAttempts;

            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var c_prev_log = localStorage.getItem(taskID + "_c_test_log");
            localStorage.setItem(taskID + "_test_state", c_prev_xml);
            localStorage.setItem(taskID + "_test_log", c_prev_log);

            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            AG_bar_graded(prev_log);
            populateFeedback(prev_log);
            prev_log.numAttempts = numAttempts;
            ide.openProjectString(c_prev_xml);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToLastState(snapWorld, taskID) {

            var ide = snapWorld.children[0];
            var prev_xml = localStorage.getItem(taskID + "_test_state");
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            prev_log.snapWorld = snapWorld;
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            ide.openProjectString(prev_xml);
            grayOutButtons(snapWorld, taskID);
        }

        function revertToLastSubmit(snapWorld, taskID) {
            var numAttempts = JSON.parse(localStorage.getItem(taskID + "_test_log")).numAttempts;

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var ide = snapWorld.children[0];

            localStorage.setItem(taskID + "_test_state", last_xml);
            localStorage.setItem(taskID + "_test_log", last_log);
            var prev_log = JSON.parse(localStorage.getItem(taskID + "_test_log"));
            if (prev_log['allCorrect']) {
                AG_bar_graded(prev_log);
            } else {
                AG_bar_semigraded(prev_log);
            }
            populateFeedback(prev_log);
            prev_log.numAttempts = numAttempts;
            ide.openProjectString(last_xml);
            grayOutButtons(snapWorld, taskID);

        }

        /*
         * Makes AG status bar reflect the ungraded state of the outputLog.
         */
        function AG_bar_ungraded(outputLog) {
            var button_text = "GRADE";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'orange');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'white');
            if (localStorage.getItem(outputLog.taskID + "_test_log")) {
                $('#feedback-button').html("View Previous Feedback");
            } else {
                $('#feedback-button').html("No Feedback Available");
            }
            document.getElementById("different-feedback").innerHTML = "This feedback does not match what is in the scripting area."
        }

        /*
         * Makes AG status bar reflect the graded state of the outputLog. This
         * only occurs when all tests on the outputLog have passed.
         */
        function AG_bar_graded(outputLog) {
            var button_text = "TESTS PASS";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp(button_text,"g");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', '#29A629');
            });
            $('#autograding_button .hover_darken').hide();
            $('#onclick-menu').css('color', 'white');
            $('#feedback-button').html("Review Feedback");
        }
        /*
         * Makes AG status bar reflect the semi graded state of the outputLog.
         * This is called when any test on the outputLog fails.
         */
        function AG_bar_semigraded(outputLog) {
            var button_text = "&#x2770&#x2770 FEEDBACK";
            var button_elem = $('#autograding_button span');
            var regex = new RegExp("FEEDBACK","g");
            var num_errors = outputLog.testCount - outputLog.numCorrect;
            var plural = "";
            if (num_errors > 1) { plural = "s"};
            $('#feedback-button').html("View Feedback ("+
                num_errors +" Error" + plural + ")");
            if (button_elem.html().match(regex) !== null) {
                return;
            }
            button_elem.fadeOut('fast', function() {
                button_elem.html(button_text);
                button_elem.slideDown('fast');
                $('#autograding_button').css('background', 'red');
            });
            $('#autograding_button .hover_darken').show();
            $('#onclick-menu').css('color', 'orange');
        }

        /* Checks if two Snap! XML strings have approximately the same state.
         * The positions of scripts are ignored, as well as the order in which
         * they were most recently manipulated.
         * @param {String} prev_xml
         * @param {String} curr_xml
         * @return {Boolean} Equivalence of prev_xml and curr_xml, false if
         * either are strings are undefined.
         * Currently only works for one sprite with scripts
         * TODO: Extend to all script groups [DONE]
         * TODO: Improve XML scrubbing (Consider the following)
         *  - If correct solution (scripts) is subset of other [DONE]
         *  - Optional tags for variables, sprite position
         *  - Option to restore the highest scoring {gradingLog}
         *
         * Note: Apparently works with multiple sprites, but produces a malformed
         * Snap XML string. Each sprite gets all scripts in sorted order. Needs
         * further testing.
        */
        function isSameSnapXML(prev_xml, curr_xml, no_subset) {
            //replace script coordinates with generic 'x="0" y="0"'
            // console.log('isSameSnapXML');
            if ((prev_xml === null) || (curr_xml === null)) { return false; }
            //Remove script coordinates
            // prev_xml = prev_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            // curr_xml = curr_xml.replace(/script x="[\d]*" y="[\d]*"/g, 'script x="0" y="0"');
            prev_xml = prev_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            curr_xml = curr_xml.replace(/script x="(.*?)" y="(.*?)"/g, 'script x="0" y="0"');
            //Remove data hashes hashes (to allow coherence b/w reloads).
            prev_xml = prev_xml.replace(/data:image(.*?)(?=<)/g, '');
            curr_xml = curr_xml.replace(/data:image(.*?)(?=<)/g, '');
            //If XML is identical other than images and script positions, short-circuit
            if (prev_xml === curr_xml) { return true; }
            //split between brackets
            prev_xml_scripts = prev_xml.match(/(<script x)(.*?)(<\/script>)/g);
            curr_xml_scripts = curr_xml.match(/(<script x)(.*?)(<\/script>)/g);
            //split between custom blocks
            prev_xml_blocks = prev_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            curr_xml_blocks = curr_xml.match(/(<block-definition s)(.*?)(\/block-definition>)/g);
            //sort script tags and convert back to strings
            //lol. weird syntax. doesn't sort if curr_xml_scripts === null.
            prev_xml_scripts && prev_xml_scripts.sort().join("");
            curr_xml_scripts && curr_xml_scripts.sort().join("");
            //If the custom block definitions have changed
            prev_xml_blocks && prev_xml_blocks.sort().join("");
            curr_xml_blocks && curr_xml_blocks.sort().join("");
            if(JSON.stringify(prev_xml_blocks) !== JSON.stringify(curr_xml_blocks)) {
                return false;
            }
            //If the previous scripts are a subset of current scripts
            if (!no_subset && isArrSubset(curr_xml_scripts, prev_xml_scripts)) {
                //Then the solution is still present and in-tact
                return true;
            }
            //replace unsorted scripts with sorted scripts
            //TODO: Replace them properly
            prev_xml = prev_xml.replace(/(<script x)(.*)(<\/script>)/g,prev_xml_scripts);
            curr_xml = curr_xml.replace(/(<script x)(.*)(<\/script>)/g,curr_xml_scripts);
            return prev_xml === curr_xml;
        }

        /*
         * Helper Function for isSameSnapXML(...). Used to check if a previous
         * solution is a sub-set of the current Snap! scripts.
         * @param {Array:Strings} big
         * @param {Array:String} small
         * @return {Boolean} If 'small' is a sub-set of 'big'
         */
        function isArrSubset(big, small) {
            if (!big || !small) {
                return false;
            }
            nbig = big.slice();
            var index;
            for (var elem of small) {
                index = nbig.indexOf(elem);
                if (nbig.indexOf(elem) >= 0) {
                    nbig.slice(index, 1);
                } else {
                    return false;
                }
            }
            return true;
        }

        function escapeRegExp(string) {
            return string.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        }

        function replaceall(string, find, replace) {
            return (string.replace(new RegExp(escapeRegExp(find), 'g'), replace));
        }

        /*
         * Re-format the contents of a the hint string to add HTML tags and
         * appropriate CSS. Return the re-formatted string.
         */
        function formatFeedback(hint) {
            var tags =
            [['collapsedivstart', '<input class="toggle-box" id="expander" type="checkbox" ><label for="expander">Details</label><div id="table-wrapper">'],
            ['collapsedivend', '</div>'],
            ['linebreak', '<br /></br />'],
            ['tablestart', '<table class="results">'],
            ['tableend', '</table>'],
            ['rowstart', '<tr>'],
            ['rowend', '</tr>'],
            ['headstart', '<th class="titles" style="text-align: center;">'],
            ['headend', '</th>'],
            ['datastart', '<td class="data" style="text-align: center;">'],
            ['evenstart', '<td class="evens" style="text-align: center;">'],
            ['dataend', '</td>'],
            ['correctstart', '<td class="correctans" style="text-align: center;">'],
            ['wrongstart', '<td class="incorrectans" style="text-align: center;">'],
            ['teststart', '<td class="tests" style="text-align: center;">'],
            ['spanend', '</span>'],
            ['spanstart', '<span class="message">']];

            var taglength = tags.length;
            var message = String(hint.innerHTML);

            for (var i = 0; i < taglength; i++) {
                message = replaceall(message, tags[i][0], tags[i][1]);
            }
            return message;
        }


        function toggleMenu() {
            var menu_items = document.getElementsByClassName("bubble")[0];
            if (menu_items.id === "dropdown-closed") {
                menu_items.id = "dropdown-open";
            } else {
                menu_items.id = "dropdown-closed";
            }
        }

        function openPopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.remove("is-hidden");
        }

        function closePopup(){
            var overlay = document.getElementById('overlay');
            overlay.classList.add("is-hidden");
        }

        function openResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.remove("is-hidden");
        }

        function closeResults(){
            var overlay = document.getElementById('ag-output');
            overlay.classList.add("is-hidden");
        }

        function populateFeedback(outputLog) {
            var taskID = outputLog.taskID;
            var last_log = localStorage.getItem(taskID + "_last_submitted_log");
            var prev_log = localStorage.getItem(taskID + "_test_log");
            var edx_caution = document.getElementById("edx-submit-different");
            var caution = document.getElementById("different-feedback");

            console.log(outputLog);
            var glog = outputLog;
            var log = AG_log(glog);
            var feedback = log["feedback"];
            var title = log["comment"];

            console.log(feedback);

            // Checks if the grading button has been clicked
            if (title === "Please run the Snap Autograder before clicking the 'Submit' button.") {
                document.getElementById("table-data").style.display = "none";
                document.getElementById("reporter-table-data").style.display = "none";
            } else {
                document.getElementById("table-data").style.display = "table";
                document.getElementById("reporter-table-data").style.display = "table";
            }

            // Wipes the feedback clean, including if it has been populated before.
            caution.innerHTML = "";
            edx_caution.innerHTML = "";
            document.getElementById("comment").innerHTML = "";
            var tableTitles = document.getElementsByClassName("titles");
            var tableResults = document.getElementById("table-data");
            var repTableResults = document.getElementById("reporter-table-data");
            while (tableResults.children.length > 1) {
                tableResults.removeChild(tableResults.children[1]);
            }
            while (repTableResults.children.length > 1) {
                repTableResults.removeChild(repTableResults.children[1]);
            }

            // Warnings for when student's feedback differ from what's on the scripting area/what's been submitted to edX
            document.getElementById("comment").innerHTML = title;
            if (!last_log) {
                edx_caution.innerHTML = "[WARNING: You have not submitted your results to edX yet.]"
            }
            else if (last_log !== prev_log) {
                edx_caution.innerHTML = "[WARNING: These results differ from your last edX submission.]"
            }

            var nonRepTest = 1;
            var repTest = 1;
            for (i=1; i<=feedback["testCount"]; i++) {
                var test = String(i);
                console.log(test);
                var newRow = document.createElement("tr");

                // If test is not a reporter test, only add columns for Test # and Feedback
                if (feedback[test]["testClass"] !== "r") {
                    if (document.getElementsByClassName("non-reporter").length === 0) {
                        addBasicHeadings();
                    }
                    addTableCell(String(nonRepTest), "tests", newRow);
                    if (nonRepTest % 2 === 0) {
                        addTableCell(feedback[test]["pointValue"], ["data", "evens"], newRow);
                    } else {
                        addTableCell(feedback[test]["pointValue"], "data", newRow);
                    }
                    nonRepTest += 1;
                }

                // If test is a reporter test, add all columns, including input, output, and expected. Makes the background of every other row light gray.
                if (feedback[test]["testClass"] === "r") {
                    if (document.getElementsByClassName("reporter").length === 0) {
                        addReporterHeadings();
                    }
                    addTableCell(String(repTest), "tests", newRow);
                    var keys = ["pointValue", "blockSpec", "input", "output", "expOut"];
                    for (key=0; key<keys.length; key++) {
                        if (keys[key] === "blockSpec") {
                            var blockSpec = feedback[test][keys[key]];
                            // var blockSpecSliced = blockSpec.slice(2, blockSpec.length - 2);
                            // console.log(blockSpecSliced);
                            if (repTest % 2 === 0) {
                                addTableCell(blockSpec, ["data", "evens"], newRow);
                            } else {
                                addTableCell(blockSpec, "data", newRow);
                            }
                        } else {
                            if (repTest % 2 === 0) {
                                addTableCell(feedback[test][keys[key]], ["data", "evens"], newRow);
                            } else {
                                addTableCell(feedback[test][keys[key]], "data", newRow);
                            }
                        }
                    }
                    repTest += 1;
                }

                // If test is correct, make the feedback appropriately colored.
                if (feedback[test]["correct"] === true) {
                    addTableCell(feedback[test]["feedback"], "correctans", newRow);
                    //addRegradeButton("Regrade", ["data", "hidden"], newRow);
                } else {
                    addTableCell(feedback[test]["feedback"], "incorrectans", newRow);
                    //addRegradeButton("Regrade", ["data", "regrade", test], newRow);
                }

                if (feedback[test]["testClass"] === "r") {
                    document.getElementById("reporter-table-data").appendChild(newRow);
                } else {
                    document.getElementById("table-data").appendChild(newRow);
                }
            }
            console.log(outputLog);
            //outputLog.saveLog();

            // makes recently created regrade buttons clickable
            /*var regrade_buttons = document.getElementsByClassName("regrade");
            for(var i=0; i<regrade_buttons.length; i++) {
                regrade_buttons[i].onclick = function() {
                    var testId = this.classList[2];
                    regradeOnClick(outputLog, testId);
                }
            }*/
        }

        function addBasicHeadings() {
            basicCols = ["Test", "Points", "Feedback"];
            for (i=0; i<basicCols.length; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(basicCols[i]);
                //var lastCol = document.getElementById("reporter-last-column");
                var titles = document.getElementById("table-titles");
                header.classList.add("titles", "non-reporter");
                header.appendChild(text);
                titles.appendChild(header);
            }
        }

        function addReporterHeadings() {
            var columns = ["Test", "Points", "Block", "Input", "Output", "Expected", "Feedback"];
            for (i=0; i<columns.length; i++) {
                var header = document.createElement("th");
                var text = document.createTextNode(columns[i]);
                var repTitles = document.getElementById("reporter-table-titles");
                header.classList.add("titles", "reporter");
                header.appendChild(text);
                repTitles.appendChild(header);
            }
        }

        function addTableCell(text, elemClass, row) {
            var data = document.createElement("td");
            var text = document.createTextNode(text);
            data.appendChild(text);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function addRegradeButton(text, elemClass, row) {
            var data = document.createElement("td");
            var button = document.createElement("p");
            var text = document.createTextNode(text);
            button.classList.add("regrade-button");
            button.appendChild(text);
            data.appendChild(button);
            if (Array.isArray(elemClass)) {
                DOMTokenList.prototype.add.apply(data.classList, elemClass);
            } else {
                data.classList.add(elemClass);
            }
            row.appendChild(data);
        }

        function grayOutButtons(snapWorld, taskID) {
            var ide = snapWorld.children[0];
            var curr_xml = ide.serializer.serialize(ide.stage);
            //Retrieve previously graded Snap XML strings (if in localStorage).
            var c_prev_xml = localStorage.getItem(taskID + "_c_test_state");
            var prev_xml = localStorage.getItem(taskID + "_test_state");

            var last_xml = localStorage.getItem(taskID + "_last_submitted_state");

            var last_submit = document.getElementById("last-submit");
            if (last_xml === null || isSameSnapXML(last_xml, curr_xml)) {
                last_submit.style.color = "#373737";
                last_submit.style.pointerEvents = "none";
                last_submit.parentNode.id = "disabled-button";
            } else {
                last_submit.parentNode.id = "enabled-button";
                last_submit.style.color = "white";
                last_submit.style.pointerEvents = "auto";
            }

            var revert_button = document.getElementById("revert-button");
            if (c_prev_xml === null || isSameSnapXML(c_prev_xml, curr_xml)) {
                revert_button.style.color = "#373737";
                revert_button.style.pointerEvents = "none";
                revert_button.parentNode.id = "disabled-button";
            } else {
                revert_button.parentNode.id = "enabled-button";
                revert_button.style.color = "white";
                revert_button.style.pointerEvents = "auto";
            }

            var undo_button = document.getElementById("undo-button");
            if (prev_xml === null || isSameSnapXML(prev_xml, curr_xml)) {
                undo_button.style.color = "#373737";
                undo_button.style.pointerEvents = "none";
                undo_button.parentNode.id = "disabled-button";
            } else {
                undo_button.parentNode.id = "enabled-button";
                undo_button.style.color = "white";
                undo_button.style.pointerEvents = "auto";
            }
        }

        function regradeOnClick(outputLog, testId) {
            var test = outputLog[testId];
            test.graded = false;
            test.correct = false;
            outputLog.numAttempts += 1;
            if (test.testClass === "r") {
                outputLog.startSnapTest(parseInt(testId, 10));

            // for assertion tests, change feedback accordingly to whether assertion is true or false
            } else if (test.testClass === "a") {
                if (test.assertion()) {
                    test.feedback = test.pos_fb;
                    test.correct = true;
                } else {
                    test.feedback = test.neg_fb;
                    test.correct = false;
                }
                test.graded = true;
            }

            //What about other types of tests?

            outputLog.scoreLog();
            console.log(outputLog);
        }

        function setNumAttempts(taskID) {
            var prev_log = localStorage.getItem(taskID + "_test_log");
            if (prev_log !== null && JSON.parse(prev_log).numAttempts !== undefined) {
                return JSON.parse(prev_log).numAttempts;
            } else {
                return 0;
            }
        }

        function isEDXurl() {
            var url = window.location.href;
            if (url.indexOf("edx") !== -1) {
                return true;
            } else {
                return false;
            }
        }

        function makeOverlayButton() {
            var overlay_button = parent.document.createElement('button');
            var overlay_button_text = parent.document.createTextNode('Grade');
            overlay_button.appendChild(overlay_button_text);
            overlay_button.id = 'overlay-button';
            var button =  parent.document.getElementsByName('problem_id')[0];
            button.parentNode.insertBefore(overlay_button, button.nextSibling);
        }

        function makeFullScreenButton() {
            var autograding_bar = document.getElementById('autograding_bar');
            var full_screen_button = document.createElement('button');
            var full_screen_button_text = document.createTextNode("Full-Screen");
            full_screen_button.appendChild(full_screen_button_text);
            full_screen_button.id = "full-screen";
            full_screen_button.className = "off";
            autograding_bar.parentNode.insertBefore(full_screen_button, autograding_bar.nextSibling);
        }

        function toggleSnapWindow(button) {
            var iframe = parent.document.getElementsByTagName('iframe')[0];
            if (button.className === "off") {
                iframe.style.position = 'fixed';
                iframe.style.top = '0';
                iframe.style.right = '0';
                iframe.style.width = '100%';
                iframe.style.height = '100vh';
                iframe.style.zIndex = '16777270';
                button.className = "on";
                button.innerHTML = "Windowed";
                /*button.style.position = 'fixed';
                button.style.right = '0';
                button.style.bottom = '0';*/
                sessionStorage.setItem("full-screen-on", JSON.stringify(true));
            } else {
                iframe.style.position = 'initial';
                iframe.style.top = 'initial';
                iframe.style.right = 'initial';
                //iframe.style.width = 'initial';
                iframe.style.height = '500px';
                iframe.style.zIndex = 'initial';
                button.className = "off";
                button.innerHTML = "Full-Screen";
                sessionStorage.removeItem("full-screen-on");
                /*button.style.position = 'absolute';
                button.style.right = '31px';
                button.style.bottom = '225px';*/
            }
        }

        /*var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));

        if (pageLocation) {
            parent.window.scrollTo(pageLocation[0], pageLocation[1]);
            sessionStorage.removeItem("pageLocation");
        }*/

        /*$( parent.document ).ready(function() {
            var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));

            if (pageLocation) {
                parent.window.scrollTo(pageLocation[0], pageLocation[1]);
                sessionStorage.removeItem("pageLocation");
            }
        });*/

        var world;
        window.onload = function () {

            /*var pageLocation = sessionStorage.getItem("pageLocation");

            if (pageLocation) {
                parent.window.scrollTo(pageLocation[0], pageLocation[1]);
            }*/

            //check if attempt num for problem exists in local storage:

            //AUTOGRADER ADDITION - FEEDBACK FORMATTING
            // Checks if problem has been checked and modifies the autograded output if it has been checked

            if (parent.document.getElementsByClassName("message").length !== 0) {
                var hint = parent.document.getElementsByClassName("message")[0];
                hint.innerHTML = formatFeedback(hint);
                hint.style.display = "inline";
            }


            //INITIALIZE UP SNAP
            world = new WorldMorph(document.getElementById('world'));
            new IDE_Morph().openIn(world);



            var ide = world.children[0];
            //console.log(starterXML);
            //ide.openProjectString(starterXML);

            //Reduce Stage Size on initialization
            ide.toggleStageSize(true);

            //AUTOGRADER ADDITION
            //Check if Pre-requisite task has completed
            var req_check = parent.document.getElementById("pre_req");
            if (preReqTaskID !== null) {
                var preReqLog = JSON.parse(localStorage.getItem(preReqID + "_test_log"));
                if ((preReqLog === null || !preReqLog.allCorrect) && req_check) {
                    req_check.innerHTML = "[WARNING: The previous task must be completed before continuing.]"
                }
            }

            //If page has already been loaded, restore previously tested XML
            //TODO: Separate this into its own function.
            var prev_xml = localStorage.getItem(id + "_test_state");
            if (prev_xml !== null) {
                ide.openProjectString(prev_xml);
            } else if (preReqTaskID !== null) {
                if (preReqLog !== null && preReqLog.allCorrect) {
                    ide.openProjectString(localStorage.getItem(preReqID));
                }
            }

            /*var starter_xml = sessionStorage.getItem("starter_file");
            if (starter_xml) {
                ide.openProjectString(starter_xml);
                //sessionStorage.removeItem("starter_file");
            }*/


            if (isEDX) {
                parent.document.getElementsByClassName('check-label')[0].onclick = function () {
                    sessionStorage.setItem("pageLocation", JSON.stringify([parent.window.scrollX, parent.window.scrollY]));
                }
            }


            //AUTOGRADER ADDITION -
            //Forced to use setTimeout() to let the world load before... Maybe not.

            //Create a gradingLog and initialize the AG status bar (AGSB).
            // var testLog = AGStart(world, id);

            //Initialize AGSB button.
            var grade_button = document.getElementById("autograding_button");
            grade_button.style.cursor = "pointer";
            //Call the test suite when this element is clicked.
            var update_listener = function() {
                var outputLog = AGUpdate(world, id);
                //populateFeedback(outputLog);
                //runAGTest(world, id);
            };
            var button_listener = function(event) {
                event.stopPropagation();
                console.log('PROPAGATION SHOULD STOP');
                var numAttempts = setNumAttempts(id);
                outputLog = new gradingLog(world, id, numAttempts);
                outputLog.numAttempts += 1;
                runAGTest(world, id, outputLog);
                //sessionStorage.setItem("pageLocation", [parent.window.scrollY, parent.window.scrollX]);
                // var outputLog = AGStart(world, id);
            }
            grade_button.addEventListener('click', button_listener);
            var world_canvas = document.getElementById('world');
            world_canvas.addEventListener("mouseup", update_listener);


            // grade_button.onclick = function(event) {
            //     // event.stopPropagation();
            //     runAGTest(world, id);
            //     var outputLog = AGStart(world, id);
            //     //console.log(outputLog);
            //     //populateFeedback(outputLog);
            // }



            var reset_button = document.getElementById("reset-button");
            var revert_button = document.getElementById("revert-button");
            var undo_button = document.getElementById("undo-button");
            var last_submit = document.getElementById("last-submit");
            //var menu_button = document.getElementById("hamburger-menu");
            var menu_button = document.getElementsByClassName("onclick-menu")[0];
            //var help_menu = document.getElementById("circle");
            var help_overlay = document.getElementById('overlay');
            var feedback_button = document.getElementById("feedback-button");
            var results_overlay = document.getElementById("ag-output");
            var snapWorld = document.getElementById("world");
            var regrade_buttons = document.getElementsByClassName("regrade");

            //var outside_menu = document.getElementById("outside-menu");

            reset_button.onclick = function() { resetState(world, id); toggleMenu(id); };
            revert_button.onclick = function() { revertToBestState(world, id); toggleMenu(id); };
            last_submit.onclick = function() { revertToLastSubmit(world, id); toggleMenu(id); };
            undo_button.onclick = function() { revertToLastState(world, id); toggleMenu(id); };
            menu_button.onclick = function() { toggleMenu(id); };
            //var overlay_button = parent.document.getElementById('overlay-button');
            //overlay_button.onclick = function() { grade_button.click(); }

            $(".bubble").click(function(event){
                event.stopPropagation();
            });

            feedback_button.onclick = function() {
                openResults();
            }

            help_overlay.onclick = function(e) {
                if (!(document.getElementById('help-popup').contains(e.target))) {
                    closePopup();
                }
            }

            results_overlay.onclick = function(e) {
                if (!(document.getElementById('ag-results').contains(e.target)) && e.target.className.indexOf("regrade") === -1) {
                    closeResults();
                }
            }

            snapWorld.onclick = function(e) {
                if (document.getElementById('dropdown-open') !== null && !(document.getElementById('onclick-menu').contains(e.target))) {
                    toggleMenu();
                }
            }


            /*outside_menu.onclick = function(e) {
                if (document.getElementById('dropdown-open') !== null && !(document.getElementById('onclick-menu').contains(e.target))) {
                    toggleMenu();
                }
            }*/

            /* Check if the snap xml has changed "significantly".
             * Exclude script position and edit history.
             */


            document.addEventListener("click", function() {
                grayOutButtons(world, id);
            });

            if (isEDX) {
                makeOverlayButton();
                var overlay_button = parent.document.getElementById('overlay-button');
                //overlay_button.style.display = "block";
                overlay_button.onclick = function() {
                    overlay_button.style.display = "none";
                    grade_button.click();
                }

                makeFullScreenButton();
                var full_screen = document.getElementById('full-screen');
                full_screen.onclick = function() {
                    toggleSnapWindow(full_screen);
                }

                var full_screen_on = JSON.parse(sessionStorage.getItem("full-screen-on"));
                if (full_screen_on) {
                    var iframe = parent.document.getElementsByTagName('iframe')[0];
                    iframe.style.position = 'fixed';
                    iframe.style.top = '0';
                    iframe.style.right = '0';
                    iframe.style.width = '100%';
                    iframe.style.height = '100vh';
                    iframe.style.zIndex = '16777270';
                    full_screen.className = "on";
                    full_screen.innerHTML = "Windowed";
                    //toggleSnapWindow(full_screen);
                    //sessionStorage.removeItem("full-screen-on");
                    sessionStorage.setItem("full-screen-on", JSON.stringify(true));
                }
            }

            IDE_Morph.prototype.originalOpenProject = IDE_Morph.prototype.openProjectString;
            IDE_Morph.prototype.openProjectString = function (name) {
                this.originalOpenProject(name);
                setTimeout(function() {
                    AGUpdate(world, id);
                }, 500);
                //runAGTest(world, id);
            }

            IDE_Morph.prototype.originalCloudOpenProject = IDE_Morph.prototype.openCloudDataString;
            IDE_Morph.prototype.openCloudDataString = function (name) {
                this.originalCloudOpenProject(name);
                setTimeout(function() {
                    AGUpdate(world, id);
                }, 500);
                //runAGTest(world, id);
            }

            IDE_Morph.prototype.originalToggleStageSize = IDE_Morph.prototype.toggleStageSize;
            IDE_Morph.prototype.toggleStageSize = function (isSmall) {
                this.originalToggleStageSize(isSmall);
                setTimeout(function() {
                    moveAutogradingBar()
                }, 100);
            }

            function moveAutogradingBar() {
                var autograding_bar = document.getElementById('autograding_bar');
                var ide = world.children[0];
                if (ide.stageRatio === 1) {
                    autograding_bar.style.right = '9em';
                } else {
                    autograding_bar.style.right = '16em';
                }
            }

            /*setTimeout(function() {
                var pageLocation = JSON.parse(sessionStorage.getItem("pageLocation"));

                if (pageLocation) {
                    parent.window.scrollTo(parseInt(pageLocation[0]), parseInt(pageLocation[1]));
                    sessionStorage.removeItem("pageLocation");
                }
            }, 3000);*/


            //TODO: Fix this timeout.
            setTimeout(function() {

                console.log(world);
                var outputLog = AGStart(world,id);
                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so populateFeedback has to be called twice at the very beginning...
                populateFeedback(outputLog);
                populateFeedback(outputLog);



                var starter_xml = sessionStorage.getItem("starter_file");
                if (starter_xml) {
                    ide.openProjectString(starter_xml);
                    sessionStorage.removeItem("starter_file");
                }

                //runAGTest(world, id);
                //runAGTest(world, id);

                /*if (isEDX) {
                    var full_screen = parent.document.getElementById('full-screen');
                    full_screen.onclick = function() {
                        toggleSnapWindow(full_screen);
                    }
                }*/

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so populateFeedback has to be called twice at the very beginning...
                //populateFeedback(outputLog);
                //populateFeedback(outputLog);
                grayOutButtons(world, id);

                /*$(".regrade").click(function() {
                    var testId = this.classList[2];
                    var test = outputLog[testId];
                    test.graded = false;
                    test.correct = false;
                    outputLog.scoreLog;
                    console.log(outputLog);
                    var mylog = outputLog;
                    //this.classList[2]);
                });*/


                /*for (i=0; i<regrade_buttons.length; i++) {
                    regrade_buttons[i].setAttribute('onclick', 'alert("hello")');
                }*/
                //populateFeedback(outputLog);
                //var outputLog = AGStart(world,id);
                //populateFeedback(outputLog);

                //for some reason, the for loop in populateFeedback doesn't increment correctly the first time it is run, so runAGTest has to be called twice at the very beginning...
                //runAGTest(world,id);
                //runAGTest(world,id);
                //AGUpdate(world, id);


            },500);

            /*var overlay_button = document.createElement('button');
            var overlay_button_text = document.createTextNode('Grade');
            overlay_button.appendChild(overlay_button_text);
            overlay_button.id = 'overlay-button';
            alert(parent.document.getElementsByName('action').length);
            parent.document.getElementsByName('action')[0].appendChild(overlay_button);*/

            //runAGTest(world,id);
            //AGUpdate(world, id);

            setInterval(loop, 1);

        };

        function loop() {
            world.doOneCycle();
        }

    </script>
    <script type="text/javascript" src="AG_EDX.js"></script>
</head>
<body style="margin: 0;">
    <canvas id="world" tabindex="1" style="position: absolute;" ></canvas>



<!-- Snap Autograding Button -->
<!--<div id="outside-menu">-->
<div id="autograding_bar">
    <div tabindex="0" class="onclick-menu" id='onclick-menu' style="display:inline-block">
        <span title="Menu">&#9776;</span>
        <div class='hover_darken'></div>
      <nav id="navigation" class="site-navigation" role="navigation">
          <ul id="dropdown-closed" class="bubble">
            <li class="menu-item-sub-menu" id="enabled-button"><a id="feedback-button">View Feedback</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="revert-button">Revert To Best Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="last-submit">Revert To Last edX Submission</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="undo-button">Revert To Last Attempt</a></li>
            <li class="menu-item-sub-menu" id="enabled-button"><a id="reset-button">Reset</a></li>
            <li class="menu-divider-sub-menu" id='menu-divider'></li>
            <li class="menu-item-sub-menu" id='enabled-button' onclick="openPopup();"><a id="help-button">Help</a></li>
          </ul>
    </nav>
    </div>
    <!-- <div id="autograding_flag" style="display:inline-block"></div> -->
    <!-- <div style="display:inline-block"> -->
    <div id="autograding_button" style="display:inline-block;">
        <span></span>
        <div class='hover_darken'></div>
    </div>
    <!-- </div> -->


<!-- Snap Autograding Menu -->

</div>
<!--</div>-->

<!-- Autograding Menu Help Button -->
<!-- <div style="display:inline-block" class="AG-help-button" id="circle" onclick="openPopup();">?
</div> -->
<div class="overlay is-hidden" id="overlay">
    <div class="popup-content" id="help-popup">
        <span class="button-close" onclick="closePopup();">X</span>
            <img id="example-image" src="edX_snap_example.png">
            <p id="full-screen-arrow">&#8600;</p>
            <p id="full-screen-help">This full-screen button will pop out the Snap! window.</p>
            <p id="menu-item-arrow">&#8599;</p>
            <p id="menu-item-help">The first menu item will display the results from running the autograder.</br></br>The next three menu items will revert your current Snap! state to one of your previous attempts, depending on whether you wish to revert to your last correct attempt, to the attempt that edX has recorded, or just to your last graded attempt.</br></br>The 'Reset' button will revert to a blank Snap! project, or to a provided starter file if one is given for this problem.</p>
            <p id="ag-button-arrow">&#8593;</p>
            <p id="ag-button-help">Clicking this button will grade your current attempt and send the results to edX.</p>
            <p>
                Please remember to click the 'Submit' button below the Snap! window to obtain credit for this problem!
            </p>
            <!--<div class="example-ag-buttons" id="ex-ungraded" style="display:inline-block;">
                &#9744;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has not been run yet.
            </p>
            </br>
            <div style="display:inline-block; color: orange;">&#x26A0;</div>
            <div class="example-ag-buttons" id="ex-semigraded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, but there are some errors in the code.
            </p>
            </br>
            <div class="example-ag-buttons" id="ex-graded" style="display:inline-block;">
                &#x2713;
            </div>
            <p style="display:inline-block;">
                The Snap! autograder has been run, and all the tests have passed!
            </p>
            </br>-->
    </div>
</div>

<div style="display:inline-block" class="view-results" id="circle" onclick="openResults();">Results
</div>
<div class="overlay is-hidden" id="ag-output">
    <div class="popup-content" id="ag-results">
        <span class="button-close" onclick="closeResults();" id="popup">X</span>
        <p id = "different-feedback"></p>
        <p id = "edx-submit-different"></p>
        <p id="comment"></p>
        <table class="results">
            <tbody id="table-data">
                <tr id="table-titles">
                    <!--<th class="titles"> Test </th>
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
        </br>
        <table class="results">
            <tbody id="reporter-table-data">
                <tr id="reporter-table-titles">
                    <!--<th class="titles"> Test </th>
                    <th class="titles" id="last-column"> Feedback </th>-->
                </tr>
            </tbody>
        </table>
    </div>
</div>


    </div>
    <script type="text/javascript" src="AG_status_bar.js" />
</body>
</html>